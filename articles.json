[
  {
    "id": 2,
    "title": "APCS b966. 3. 線段覆蓋長度",
    "content": "# **APCS b966. 3. 線段覆蓋長度**\n\n*  題目連結：<br/>\n&emsp;[在這裏～～](https://zerojudge.tw/ShowProblem?problemid=b966)\n \n---\n\n## **理解題意**\n\n---\n### 目標\n給定N段線段的起點和終點，輸出線段覆蓋長，重疊的部分只能算一次\n### 範例\n![ShowImage](https://hackmd.io/_uploads/BJ2h1j0yA.png)\n* 輸入: 給4段線段長(N=4)，起點與終點分別為(5,6)、(1,2)、(4,8)、(7,9)\n* 輸出: 被覆蓋區域有(1,2)、(4,9)，共6線段長。\n---    \n    \n## 解題\n\n---\n### 解題思路\n1. 用pair結構紀錄線段的起點與終點，使程式的可讀性更高。\n2. 設一個pair一維陣列，用來記錄每一線段長。\n3. 將線段依起點數值由小到大排序。\n4. 記錄上一線段長的起點位置，用來和下一線段作比較。\n5. 判斷線段狀況，並根據每一種情況，做運算。\n6. 若為狀況一:覆蓋線段長+線段B長度\n7. 若為狀況二:覆蓋線段長+線段B終點-線段A起點\n8. 若為狀況三:覆蓋線段長不變\n:::danger \n! ! ! 解題關鍵:\n&emsp;將線段先依起點數值由小到大排序(用sort函式)，就可以確保相鄰兩線段關係只有以下三種狀況。\n:::\n* 狀況一: 線段A、B不重疊\n![IMG_0292](https://hackmd.io/_uploads/rkDY8oA1R.jpg)\n* 狀況二: 線段A後半段重疊線段B前半段\n![IMG_0293](https://hackmd.io/_uploads/S1ARLi0yC.jpg)\n* 狀況三: 線段A涵蓋線段B(兩線段完全重疊)\n![IMG_0294](https://hackmd.io/_uploads/SJW7voRk0.jpg)\n#### 排序示意圖:\n* 排序前:\n![IMG_0290](https://hackmd.io/_uploads/Bya-Vs01R.jpg)\n* 排序後:\n![IMG_0291](https://hackmd.io/_uploads/Sy7fVi0JR.jpg)\n\n### 程式碼\n\n```c++=\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\n    int N;          //共有N個線段\n    cin >> N;\n    pair<int,int> line[N];  //用pair結構建立一維陣列，紀錄線段起點和終點\n    for(int i=0;i<N;i++){\n        cin >> line[i].first >> line[i].second;\n    }\n    sort(line,line+N);      //將線段依起點數值大小排序(由小到大)\n    int right=line[0].second,ans=right-line[0].first;   //right為上一線段終點,ans是線段覆蓋長度\n    for(int i=0;i<N-1;i++){     \n        if(line[i+1].second>right){   //若線段不完全包含在上一線段內\n            if(line[i+1].first<right) ans+=line[i+1].second-right;  //若前半部重疊，ans加上為重疊部分長\n            else ans+=line[i+1].second-line[i+1].first;  //若完全不重疊，ans加上新的線段長\n        }\n        right=max(line[i+1].second,right);      //更新尾巴數值\n    }\n    cout << ans;\n    \nreturn 0;\n}\n```\n\n### 新的酷東西\n\n* pair用法\n    <br/>\n    * 個人理解:\n        &emsp;pair就是struct結構的簡略版。\n        &emsp;差別在於pair只能有兩個參數(資料型態)，而struct可有多個。\n        &emsp;若只有要用兩個參數，使用pair會比較方便，因為struct要自己寫，但pair不用。\n        \n    * 語法:\n        1. 宣告變數:\n            &emsp;&emsp;pair <資料型態,資料型態> 變數名稱\n        2. 呼叫變數:\n            &emsp;&emsp;變數名稱.first  (第一個)\n            &emsp;&emsp;變數名稱.second (第二個)\n    \n    * 範例:\n        1. 程式碼:\n        &emsp;&emsp;pair <string,float> A;\n        &emsp;&emsp;cin >> A.first >> A.second;\n        &emsp;&emsp;cout << A.first << \" : \" << A.second+10;\n        2. 輸入:\n        &emsp;&emsp;HowLong 20\n        3. 輸出:\n        &emsp;&emsp;HowLong : 30\n\n---\n## 廢話區\n---\n\n阿阿阿~終於解出來了!\n我覺得這一題很有難度，看到這題目時，我腦袋裡只有好多會TLE的想法，對於時間複雜度較低的解法，完全沒想法:sweat_smile:。\n有辦法解出這題，其實是偷了佩雯上課時提供的想法，哈哈~\n然後，我很訝異，我居然有辦法解出APCS第三題了ㄟ! (之前程度都只停留在第二題，雖然這題也是花了我好幾小時啦~)",
    "tags": "競程 ,APCS ",
    "date": "2024-04-06"
  },
  {
    "id": 3,
    "title": "a007. 判斷質數",
    "content": "# **a007. 判斷質數**\n\n*  題目連結：<br/>\n&emsp;[在這裏～～](https://zerojudge.tw/ShowProblem?problemid=a007)\n \n---\n\n## **理解題意**\n\n---\n\n### 目標\n判斷某數是否為質數，若為質數，輸出\"質數\";否則輸出\"非質數\"。\n* 範例:\n    * ( 一 ) 輸入:13 輸出:質數 \n    * ( 二 ) 輸入:18 輸出:非質數\n    \n---    \n    \n## 解題\n\n---\n### 前言\n先來講講我TLE的解法，我的作法是用自定義函式`is_Prime`來判斷n是否為函數。然後函式裡的邏輯就是讓n除以2~$\\sqrt{n}$ 的數，如果n能被整除，n就不會是質數，否則就代表n的因數只有1和自己，n就是質數。但這種作法，相當於每遇一數就要從2開始，一數一數檢查到$\\sqrt{n}$，在有多筆測資的情況下相當耗時，因此應該要先建一個質數表(只需要算一次)，之後的數字在用這個質數表作判斷。\n\n### TLE 程式碼\n\n```c++=\n#include<bits/stdc++.h>\nusing namespace std;\n\nstring is_Prime(int n){\n    int i=2;        //i是因數\n    while(i*i<=n){    //當i<=根號n時\n        if(n%i==0){    //若n能被i整除\n            return \"非質數\\n\";    //n就不是質數\n        }\n        i++;\n    }\n    return \"質數\\n\";    //若n都不能被小於根號n的數整除，n就是質數\n}\n\nint main(){\n    int n=0;        //判斷n是否為質數\n    while(cin >> n) cout << is_Prime(n);  //用自訂函式判斷n是否為質數\nreturn 0;\n}\n```\n\n### AC解題思路\n1. 因為要使用`sqrt()`，所以引入`<cmath>`函式庫。\n2. 用優化器減少TLE的機會。\n3. 建一個質數表，減少程式執行時間(才不用每次都從2開始，一數一數檢查)。\n4. 要判斷n是否為質數，只要用n除質數表中的數字即可。\n:::danger \n! ! ! 注意:\n&emsp;這題要#include\\<iostream>，不要#include<bits/stdc++.h>，不然很容易TLE。\n:::\n\n\n### AC程式碼\n\n```c++=\n#include <iostream>\n#include <cmath>    //要用sqrt要include<cmath>\nusing namespace std;\nint main(){\n\tios_base::sync_with_stdio(0);       //聽說這叫優化器\n\tcin.tie(0);\n\tint prime[5000],t=0; //prime[5000]是2~2147483647中的質數,t是質數表中的索引 \n\tbool b=1;   //若b=1，就代表是質數\n\tfor(int i=2;i<=sqrt(2147483647);i++){    \n\t\tb=1;\n\t\tfor(int j=2;j<=sqrt(i);j++){\n\t\t\tif(i%j==0){     //若i能被j整除，就不是質數\n\t\t\t\tb=0;\n\t\t\t\tbreak;\n\t\t\t}\t\t\n\t\t\t\n\t\t}\n\t\tif(b) prime[t++]=i;//若i是質數，就加入質數表\n\t}\n\t\n\tint n;      //判斷n是否為質數\n\twhile(cin>>n){\n\t\tb=1;    //若b=1，就代表是質數\n\t\tfor(int i=0;i<t;i++){   \n\t\t\tif(sqrt(n)<prime[i]) break; //若質數表中的數已經比根號n大，n就是質數\n\t\t\tif(n%prime[i]==0){  //若n能被質數表中的數整除\n\t\t\t\tb=0;            //n就不是質數\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(b) cout<<\"質數\"<<endl;\n\t\telse cout<<\"非質數\"<<endl; \n\t\t\n\t}\n\treturn 0;\n}\n```\n\n\n\n### 新的酷東西\n\n* i/o 優化\n    * 目的:\n        &emsp;降低程式TLE的機會\n        \n    * 原理:\n        &emsp;在文字被輸出前，它會先到一個「緩衝區」，不是馬上就全部輸出，而是到一個特定的時間再一次輸出出去，因為分次輸出其實算是很耗資源的事。強制將緩衝區的資料釋放（輸出）的動作稱為 `flush`。在 `iostream`，這個動作是 `cout << flush`。緩衝區的釋放是決定效率的關鍵因素，看是一次釋放、還是多次釋放，速度就會大有不同。\n       `cin` 會強制釋放，因為在要求使用者輸入之前，應該先讓使用者看見先前輸出的文字，這是介面設計上的考量，但顯然不符合競程的需要，因此我們要取消強制釋放。\n\n    :::info \n    :bulb:tip:\n     `endl` 也會自動 `flush`，也就是說，`cout << endl` 其實是 `cout <<      flush << '\\n' `，想解決此問題，只要改用`cout << '\\n' `就可以了。\n    :::\n    \n    * 語法:\n        &emsp;取消強制釋放：`cin.tie(0)`;\n        &emsp;解除 `iostream` 和 `stdio` 同步: `ios_base::sync_with_stdio(false)`;\n        \n    * 資料參考: [點我看更多](https://hackmd.io/@wiwiho/CPN-io-optimization)\n\n\n---\n## 廢話區\n---\n\n剛開始看到這題目，我想說怎麼又是判斷質數，然後我自信滿滿的寫了一個比之前都還要短、簡潔明瞭的程式，結果居然TLE。所以我只好換另一種解法(也就是建質數表)，這種方式好像比較直觀，但我不知道為什麼，第一想法居然不是這個，或許是之前解題經驗關係吧? \n(雖然但是，我認真覺得我 TLE 的程式碼比較漂亮。:point_right::point_left:)",
    "tags": "競程",
    "date": "2024-04-08"
  },
  {
    "id": 4,
    "title": "APCS f580. 2.骰子",
    "content": "# **APCS f580. 2.骰子**\n\n*  題目連結：<br/>\n&emsp;[在這裏～～](https://zerojudge.tw/ShowProblem?problemid=f580)\n \n---\n\n## **理解題意**\n\n---\n\n### 操作方式\n* 將骰子向前轉(b=-1)\n![IMG_0281](https://hackmd.io/_uploads/Hyo2KyHyA.jpg)\n* 將骰子向右轉(b=-2)\n![IMG_0285](https://hackmd.io/_uploads/BJO2Xd8JC.jpg)\n* 交換兩顆骰子(a、b都是正數)\n![IMG_0283](https://hackmd.io/_uploads/SkFwoJrJR.jpg)\n### 目標\n全部操作完後，依序輸出每顆骰子頂部的點數\n* 範例:\n![IMG_0284](https://hackmd.io/_uploads/H1CZMgH1C.jpg)\n    * 範例一 輸出: 3 1 \n    * 範例二 輸出: 2 5 6\n    \n---    \n    \n## 解題\n\n---\n### 解題思路\n1. 用struct結構紀錄骰子頂部、前方、右方的點數，使程式的可讀性更高。\n2. 設一個struct一維陣列，用來記錄每一顆骰子狀態。\n3. 若a、b皆為正數，就用swap()交換兩顆骰子。\n4. 若b為-1，就將邊號a的骰子向前旋轉。\n5. 若b為-2，就將邊號a的骰子向右旋轉。\n6. 全部操作完後，依序輸出每顆骰子頂部的點數。\n:::danger \n! ! ! 解題關鍵:<br/>\n&emsp;每一面骰子和對面的點數加給來都是7，所以在翻面的時候，只要用7-目前前方的點數，就能知道新的骰子狀態。\n:::\n* 例如:\n![IMG_0281](https://hackmd.io/_uploads/r1Xs7WHkR.jpg)\n    * 原本前方是4，右方是2，頂部是1，將骰子向前轉後，前方變成1 (原本的頂部)，右方是2 (不變)，頂部變成3 (7-原本前方點數4)。\n\n\n### 程式碼\n\n```c++=\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct TheDice{     //struct紀錄骰子頂部、前方和右方的點數\n    int top=1,right=2,infront=4;    //設定初始值\n};\n\nint main(){\n    int n,m;            //n是骰子數，m是操作次數\n    cin >> n >> m;\n    TheDice dice[n];    //陣列儲存每顆骰子的狀態\n    for(int i=0;i<m;i++){\n        int a,b;        //a為要被操作的骰子編號，b是操作動作\n        cin >> a >> b;\n        if(b>0){        //若b為正數，則交換編號a和編號b的骰子\n            swap(dice[a-1],dice[b-1]);\n        }\n        else if(b==-1){ //若b為-1，邊號a的骰子向前旋轉\n            int tem=dice[a-1].infront;\n            dice[a-1].infront=dice[a-1].top;\n            dice[a-1].top=7-tem;\n        }\n        else{           //若b為-2，邊號a的骰子向右旋轉\n            int tem=dice[a-1].right;\n            dice[a-1].right=dice[a-1].top;\n            dice[a-1].top=7-tem;\n        }\n    }\n    for(int i=0;i<n;i++){   //輸出每顆骰子頂部的點數\n        cout << dice[i].top << \" \";\n    }\n    cout << endl;\nreturn 0;\n}\n```\n\n### 新的酷東西\n\n* swap用法\n    * 目的:<br/>\n        &emsp;交換兩個變數的值\n    * 語法:<br/>\n        &emsp;swap(a,b)\n    * 範例:<br/>\n        &emsp;(一.)<br/>\n        &emsp;&emsp;若 a=5 ， b=10<br/> \n        &emsp;&emsp;swap(a,b)<br/>\n        &emsp;&emsp;a=10 b=5<br/>\n        &emsp;(二.)<br/>\n        &emsp;&emsp;若 arr[0]='a' , arr[1]='b'<br/>\n        &emsp;&emsp;swap(arr[0],arr[1])<br/>\n        &emsp;&emsp;arr[0]='b' arr[1]='a'<br/>\n\n\n---\n## 廢話區\n---\n\n這一題我想很久，終於想出來怎麼寫了，我很開心，所以特地為它寫了這篇，哈哈~<br/>\n我覺得這一題的程式碼不會太難，主要是難在該怎麼判斷骰子前後左右點數是什麼，這一點我找很久才找到。一開始，我一直在觀察骰子的相鄰兩面有沒有什麼規律，是相加為一定數?相乘是定值?還是相差一樣的數字，但都找不到關聯性。後來因為段考後閒閒沒事做，直接拿了實體骰子起來看，東翻翻，西轉轉，終於被我看出來了!我發現骰子每面和對面的點數和是7，只要觀察出這點，之後很快就把程式寫出來啦!",
    "tags": "競程 ,APCS ",
    "date": "2024-04-17"
  },
  {
    "id": 5,
    "title": "Unity 筆記",
    "content": "# Debug\nDebug.Log(123); //consolon print 123\n\n# move\n* transform.Translate(1,0,0); //x,y,z\n* transform.Translate(1,0.1f,0); //only float not double, so press f\n* transform.Translate(0,0.01f*Time.deltaTime,0); //press Time.deltaTime to avooid each computer runtime not same\n# add someting in inspecter\n* [SerializeField] float moveSpeed = 5f; //[SerializeField] -> gobal and can change in inspecter\n# dectect communite\n### press keyborad?\n* Input.GetKey(KeyCode.RightArrow)\n* Input.GetKey(KeyCode.LeftArrow)\n* Input.GetKey(KeyCode.upArrow)\n* Input.GetKey(KeyCode.downArrow)\n* Input.GetKey(KeyCode.A)\n\n# Rigidbody 2D\n* inspecter -> Add Component -> Rigidbody 2D\n* There are mass and gravity etc like reallife\n* Constraints -> Freeze Rotation 打勾可使他不旋轉\n\n# 碰撞?\n* inspecter -> Add Component -> collider\n* squere -> Box Collider 2D(3D)\n* circle -> Circle Collider 2D(3D)\n* add tag to hierarchy and than you can coding!\n```C#= \nvoid OnCollisionEnter2D(Collision2D other) {\n        if(other.gameObject.tag == \"Floor1\"){\n            Debug.Log(\"ㄚㄚㄚ\");\n        }\n        else if(other.gameObject.tag == \"Floor2\"){\n            Debug.Log(\"2222\");\n        }\n    }\n```\n* other.contacts[0].point -> 取得角色碰撞點座標位置\n* other.contacts[0].normal -> 取得角色碰撞法向量座標位置\n\n# is Tigger\n* inspecter -> Box collider -> is Tigger [V] only Dectect not 碰撞\n* 把OnCollisionEnter2D改成OnTriggerEnter2D\n```C#=\n    void OnTriggerEnter2D(Collider2D other)\n    {\n        //經過時執行\n        if(other.gameObject.tag == \"DeathLine\"){\n            Debug.Log(\"WA\");\n        }        \n    }\n```\n\n# 角色圖層\n* Sprite Renderer -> Additional Settings -> Order in Layer (more number it is, much award)\n* 可以把角色做成模板(prefab)。把角色拉到Assets即可。要用的時候從Assets拉到畫面即可。\n* Prefab就可以一次改變顏色、尺寸等等\n\n# UI\n* UI中的canva下的子物件，可蓋過所有遊戲畫面",
    "tags": "專題 ",
    "date": "2024-08-25"
  },
  {
    "id": 6,
    "title": "強化學習_CartPole小提示",
    "content": "# CartPole 小提示\n### Space?\n* state\n  * state[0] -> Cart Position\n  * state[1] -> Cart Velocity\n  * state[2] -> Pole Angle\n  * state[3] -> Pole Angular Velocity\n* action\n  * action=0 -> Push cart to the **==left==**\n  * action=1 -> Push cart to the **==right==**\n### 目標?\n* 不要讓桿子倒下，撐越久越好\n### 邏輯?\n* 我有用到state[0]、state[2]、state[3]\n* 先判斷桿子的角度和速度(角度和速度不能太大)\n* 再判斷車子的位置(盡量讓車子在中間)\n> 不要問我怎麼知道的，我就是一直~~亂試~~\n### 實作\n:::spoiler\n```py=\ndef Policy(state):\n    if state[2]>0.08 or state[3]>0.6:\n      action=1\n    elif state[2]<-0.08 or state[3]<-0.6:\n      action=0\n    else:\n      if state[0]<0:\n        action=0\n      else:\n        action=1\n    return action\n```\n:::\n### 成果?\n* 它看起來搖搖欲墜(~~跟我的精神狀態一樣~~)，但它確實是500分\n\n{%youtube aaUQPH62V2w %}\n\n* 有看不懂的再來問我😊",
    "tags": "專題 ,AI ",
    "date": "2024-09-15"
  },
  {
    "id": 7,
    "title": "關於 github 資料夾",
    "content": "# 關於 github 資料夾\n\n## 上傳\n\n### 先到github右上角的+，點New repository\n![螢幕擷取畫面 2024-10-18 213903](https://hackmd.io/_uploads/S16N8keeyx.png)\n### 輸入專案名稱，並選擇公開或私人\n![螢幕擷取畫面 2024-10-18 213944](https://hackmd.io/_uploads/rJwrIyllJl.png)\n### 在本機cmd，移動到要上傳的資料夾路徑\n``` cd C:\\your\\path```\n### 在cmd輸入以下指令\n``` \ngit add .\ngit commit -m \"Initial commit\"\n```\n### 接著回到github，複製這三行指令到cmd\n![螢幕擷取畫面 2024-10-18 215034](https://hackmd.io/_uploads/H1XGdyleJx.png)\n### 好耶!完成了\n![螢幕擷取畫面 2024-10-18 215521](https://hackmd.io/_uploads/H19Wtyleyg.png)\n\n## 下載\n### 在cmd中打這一行，就可以下載下來\n```\ngit clone github資料夾網址.git\n```\n### 如果想把修改後的資料夾再上傳到github\n```\ngit add .\ngit commit -m \"變更訊息\"\ngit push origin main\n```",
    "tags": "專題 ",
    "date": "2024-10-18"
  },
  {
    "id": 8,
    "title": "APCS CAMP 筆記",
    "content": "# 目標 演算法 : 57題 (已完成27題)\n\n# 區間DP、雙指針不懂\n\n# 作弊long long int法\n寫了 ```#define int long long``` 後再把```int main()```改成```signed main()```。之後程式碼只要寫```int```，他的型態就直接是```long long int```了!\n:::danger\n! 注意 :\n除了APCS、競程，其他情況盡量不要用(例如:寫專案，因為記憶體會爆炸)\n:::\n\n\n# 條件式酷方法\n### (條件 ?  成立執行 : 不成立執行)\n#### 舉例1: 如果a==1就加上5否則等於0\n```c\na+=(a==1 ? 5 : -a);\n```\n#### 舉例2: 如果a>0就輸出a否則輸出0\n```c\ncout << (a>0 ? a : 0);\n```\n### 好酷!\n```c\nans+=sum==m。\n```\n* 如果 ```sum==m```，```ans+=sum```\n\n### 不輸出行尾空白的方法\n```c=\nint a[n+5][m+5]={0};\nfor(int i=0;i<n;i++){\n    for(int j=0;j<m;j++){\n         cout << a[i][j] << \"*\\n\"[j==m-1];   \n    }\n}\n```\n* 若```n=2```，```m=3```。會輸出:\n```\n0*0*0\n0*0*0\n```\n\n* ```\"*\\n\"[j==m-1]```\n如果後面的判斷式是1，就輸出字串索引1的```\\n```，否則輸出字串索引0的```*```\n\n# Vector\n### vector 比大小\n* 從array[0]開始比\n例如:\na={1,2,3}\nb={1,4,3}\n結果 ```b>a```\n因為```a[0]==b[0]```但```a[1]<b[1]```\n\n\n# struct\n感覺struct有點像python裡的class?\n### 奇怪初始化方式\n```c=\nstruct Dog{\n    //初始化(aa的值給a，bb的值給b，cc的值給c)\n    Dog(int aa,int bb,int cc):\n        a{aa},b{bb},c{cc}{\n            //可以放程式碼也可以不放(會在初始化後執行)\n            cout << \"hi\\n\";\n        }\n    //struct的變數\n    int a,b,c;\n};\n```\n* ```Dog dog(2,5,7)``` 就可以初始化dog的a、b、c\n### 結構函式\n```c=\nstruct Dog{\n    void say(){\n        cout << \"hi\";\n    }\n};\n```\n* ```dog.say()``` 就可以輸出\"hi\"\n\n\n# 時間複雜度\n### O(10^8~10^9)大約會執行1秒\n* ```sort(arr,arr+n)``` -> O(n log n)\n* ```log(n)``` -> O(n)\n* 遍歷 -> O(n)\n* max_element() -> O(n)\n:::info\n! 小提醒 :\nvector雖然push只有O(e)，但insert()需要把所有資料往後平移，所以可能會TLE\n:::\n### ios 優化器\n```c=\ncin.tie(0);\nios::sync_with_studio(false);\n```\n:::danger\n! 注意 : \n加了優化器後， endl 都要改成 \"\\n\" 才會達到優化效果。\n:::\n\n\n# DSU\n### 路徑壓縮:只要知道點屬於哪個集合(例如:~~我知道我的未來不是夢~~。我知道A屬於B，但不需知道B的父節點是A)\n## 常用於合併、集合問題\n```C\n\n```\n\n\n# 位元枚舉\n### 例如:用二進位，表示狀態?\n* 20=2*(10\\^1)\n* 40=4*(5\\^1)\n* 202=2*(3\\^2)+2*(3\\^0)\n### 10進位轉換成k進位\n先取模再除k。\n#### 舉例：20 轉到三進位的步驟如下：\n1. ```20 % 3 = 2```，```20 / 3 = 6```，右放到左：2\n2. ```6 % 3 = 0```，```6 / 3 = 2```，右放到左：02\n3. ```2 % 3 = 2```，```2 / 3 = 0```，右放到左：202\n4. 要固定長度就執行到第 n 點 (一直在前面補 0)，不用的話就結束了\n### k 進位轉到 10 進位的方法，就是左取到右，先乘再加重複 n 次\n#### 舉例：三進位的 202 轉成十進位的步驟如下\n1. 左取到右：2，```ans ≔ ans×3 + 2```，ans = 2\n2. 左取到右：0，```ans ≔ ans×3 + 0```，ans = 6\n3. 左取到右：2，```ans ≔ ans×3 + 2```，ans = 20\n\n# 貪心\n### 硬幣問題\n* 只有==一個面額==或面額都成==倍數關係==，就可以做貪心。\n\n# 圖論\n### 存圖(用vector存)\n* graph[節點].push_back( {連接的節點,邊權} )\n* {連接的節點,邊權}是一個pair\n* W[節點][點權]\n### DFS\n#### 計算連通塊數量\n* 枚舉每個點進行DFS。看總共DFS幾次就知道有幾塊連通塊。\n\n# 分治\n### 合併排序\n```cpp=\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nvector<int> arr={5,3,8,6,2,7,1,4};\n\n//排序\nvoid Merge(int start,int arr_end,int mid){\n    vector<int> LeftArr(arr.begin()+start,arr.begin()+mid+1);\n    vector<int> RightArr(arr.begin()+mid+1,arr.begin()+arr_end+1);\n    LeftArr.push_back(LLONG_MAX);\n    RightArr.push_back(LLONG_MAX);\n    int Left_id=0,Right_id=0;\n    for(int i=start;i<=arr_end;i++){\n        if(LeftArr[Left_id]<=RightArr[Right_id]){\n            arr[i]=LeftArr[Left_id];\n            Left_id++;\n        }\n        else{\n            arr[i]=RightArr[Right_id];\n            Right_id++;\n        }\n    }\n}\n\n//分割\nvoid Merge_sort(int start,int arr_end){\n    if(start < arr_end){\n        int mid=(start+arr_end)/2;\n        Merge_sort(start,mid);\n        Merge_sort(mid+1,arr_end);\n        Merge(start,arr_end,mid);\n    }\n}\n\nsigned main(){\n    Merge_sort(0,7);\n    for(auto &i:arr) cout << i << \" \";\nreturn 0;\n}\n\n```\n\n\n# 雜七雜八\n### (int) arr.size()\n如果用.size()，盡量養成(int)的習慣。才不會被轉成unsigend long long，然後溢位。\n\n### const auto &i:v\n* 不加&就是要把v裡面的值都在複製一次。但加了&就是直接把v裡面的值叫出來，可以讓時間減少。\n* 加了const就可以避免原數值被改掉\n\n\n# 上課影片\n* [APCS Camp 2024 8/12 (一) 上午 錄影紀錄](https://www.youtube.com/watch?v=EvPJpGA5B9g)\n* [APCS Camp 2024 8/12 (一) 下午 錄影紀錄](https://www.youtube.com/watch?v=9BGI6J1KYr0)\n* [APCS Camp 2024 8/13 (二) 上午 錄影紀錄](https://www.youtube.com/watch?v=ZchQIcdOPbM)\n* [APCS Camp 2024 8/13 (二) 下午 錄影紀錄](https://www.youtube.com/watch?v=CB3N6v372LU)\n* [APCS Camp 2024 8/14 (三) 上午 錄影紀錄](https://www.youtube.com/watch?v=07Hxnm4jmjg)\n* [APCS Camp 2024 8/14 (三) 下午 錄影紀錄](https://www.youtube.com/watch?v=OkiinYa5iK4)\n* [APCS Camp 2024 8/15 (四) 上午 錄影紀錄](https://www.youtube.com/watch?v=HTkW_O1asmo)\n* [APCS Camp 2024 8/15 (四) 下午 錄影紀錄](https://www.youtube.com/watch?v=kyZaHRJPYwk)\n* [APCS Camp 2024 8/16 (五) 上午 錄影紀錄](https://www.youtube.com/watch?v=TQMubmAfpyg)\n* [APCS Camp 2024 8/16 (五) 下午 錄影紀錄](https://www.youtube.com/watch?v=xsPfHfs1QjY)\n* [APCS Camp 2024 8/17 (六) 上午 錄影紀錄](https://www.youtube.com/watch?v=bMkW_uqtbGw)\n* [APCS Camp 2024 8/17 (六) 下午 錄影紀錄](https://www.youtube.com/watch?v=Ab_on7By7aE)\n* [APCS Camp 2024 8/19 (一) 上午 錄影紀錄](https://www.youtube.com/watch?v=8LC2JiOHvWQ)\n* [APCS Camp 2024 8/19 (一) 下午 錄影紀錄](https://www.youtube.com/watch?v=SVmQUc92pkE)\n* [APCS Camp 2024 8/20 (二) 上午 錄影紀錄](https://www.youtube.com/watch?v=qNdVhsR8-ys)\n* [APCS Camp 2024 8/20 (二) 下午 錄影紀錄](https://www.youtube.com/watch?v=IN5v6zV-5lw)\n* [APCS Camp 2024 8/21 (三) 上午 錄影紀錄](https://www.youtube.com/watch?v=uk-Q9P1rcGc)\n* [APCS Camp 2024 8/21 (三) 下午 錄影紀錄](https://youtu.be/jdDR4iUhuco)\n* [APCS Camp 2024 8/22 (四) 上午 錄影紀錄](https://www.youtube.com/watch?v=lYkHlMzqy6g)\n* [APCS Camp 2024 8/22 (四) 下午 錄影紀錄](https://www.youtube.com/watch?v=pssCJ_tfRRQ)\n* [APCS Camp 2024 8/23 (五) 上午 錄影紀錄](https://www.youtube.com/watch?v=DrthOBqMyIU)\n* [APCS Camp 2024 8/23 (五) 下午 錄影紀錄](https://www.youtube.com/watch?v=MR0tcrm0RMc)\n* [APCS Camp 2024 8/24 (六) 上午 錄影紀錄](https://www.youtube.com/watch?v=QYysXYtAvB8)\n* [APCS Camp 2024 8/24 (六) 下午 錄影紀錄](https://www.youtube.com/watch?v=Ljc7vNdXymw)",
    "tags": "競程 ",
    "date": "2024-10-27"
  },
  {
    "id": 9,
    "title": "🤖 Discord Bot 筆記",
    "content": "# 🤖 Discord Bot 筆記\n> [sisct 講義](https://drive.google.com/file/d/1Np7TRo6ZozY4-fdERnqxucEQngxCGfae/view?usp=sharing)\n\n---\n\n## 📌 什麼是 Discord？\n\n- **功能**：\n  - 建立主題伺服器\n  - 成員權限控制\n  - 語音、訊息互動\n- **優勢**：\n  - 好用的聊天平台\n  - 遠勝 LINE 的社群體驗\n\n---\n\n## ⚙️ 什麼是 Discord Bot？\n\n- 類似虛擬用戶，透過 **websocket + API** 與 Discord 溝通。\n- Discord Bot = 把程式透過 Discord UI 輸入/輸出\n- 自動化功能包括：\n  - 訊息回應\n  - 身分組設定\n  - 頻道建立\n  - 使用者互動等\n\n---\n\n## 🔗 什麼是 API？\n\n- 應用程式介面，讓程式間能互相溝通。\n- 在 Discord Bot 開發中使用 API（如 py-cord）來整合指令與回應。\n\n---\n\n## 🛠 如何開始製作 Bot？\n\n### 📦 需要準備：\n- Python 語言\n- py-cord 套件\n\n### ✅ 安裝步驟：\n\n#### 確認 Python 已安裝\n```\npython3 --version\n```\n\n#### 確認 pip 可用\n\n```\npip3 --version\n```\n\n#### 安裝 py-cord\n```\npip3 install py-cord\n```\n\n#### 檢查安裝成功\n```\npip3 list | grep \"py-cord\"   # Mac/Linux\npip3 list | find \"py-cord\"   # Windows\n```\n\n\n### 🧑‍💻 建立 main.py 基本結構\n#### 引入模組與初始化：\n```py\nimport discord\nfrom discord.ext import commands\n\nintents = discord.Intents.all()\nbot = commands.Bot(command_prefix=\"/\", intents=intents)\n```\n#### 啟動 bot：\n```py\n@bot.event\nasync def on_ready():\n    print(f'Logged in as {bot.user}!')\n\nbot.run(\"your_bot_token\")\n```\n### 📬 事件處理 @event\n#### 成員加入通知：\n\n```py\n@bot.event\nasync def on_member_join(member):\n    channel = bot.get_channel(YOUR_CHANNEL_ID)\n    await channel.send(f\"{member.mention} 歡迎加入！\")\n```\n#### 訊息監聽回覆：\n```py\n@bot.event\nasync def on_message(message):\n    if message.author == bot.user:\n        return\n    if message.content == \"ping\":\n        await message.channel.send(\"pong\")\n```\n### 🔀 斜線指令 @slash_command\n```py\n@bot.slash_command(name=\"hello\", description=\"Say hello!\")\nasync def hello(ctx):\n    await ctx.respond(\"Hello 👋\", ephemeral=True)\nctx.respond()：回應訊息（可設 ephemeral）\n```\n\n> 指令提示由 Discord 內建支援，UX 更佳\n\n### 🧾 使用 JSON 儲存資料\n#### 檔案格式：\n```json\n{\n  \"hello\": \"world\",\n  \"red_fruit\": [\"apple\", \"cherry\"],\n  \"flower\": \"rose\"\n}\n```\n#### Python 操作 JSON：\n```py\nimport json\n\nwith open(\"data.json\", \"r\") as f:\n    data = json.load(f)\n\nprint(data[\"hello\"])  # world\n```\n---\n## ❓ 常見問題\n* 指令未出現：重啟 Discord（Ctrl/Cmd + R）\n\n* Token 洩漏：立即 reset，避免被盜控！\n---\n## 💻 範例程式\n```py\nimport discord\nimport json\n\nwith open('data.json', 'r') as file:\n    data = json.load(file)\n\nbot = discord.Bot(intents = discord.Intents.all())\n\n# 上線提醒\n@bot.event\nasync def on_ready():   #異步函數\n    print(f\"{bot.user} 不想上班💩\")\n\n# 對話\n@bot.event\nasync def on_message(message):\n    # 避免 loop\n    if message.author == bot.user:\n        return\n    # 如果使用者船ping，機器人船pong\n    elif message.content == \"ping\":\n        await message.channel.send(\"pong\")\n    elif \"rickroll\" in message.content:\n        await message.channel.send(\"https://youtu.be/p7YXXieghto\")\n\n# 使用者加入\n@bot.event\nasync def on_member_join(member):\n    welcome_channel_id = 1370659139000340551\n    welcome_channel = bot.get_channel(welcome_channel_id)\n    await welcome_channel.send(f\"{member.mention}醬~ 嗨~ 你喜歡什麼?\")\n\n# 斜線指令\n@bot.slash_command(description=\"ping pong pong\")\nasync def ping(ctx):\n    await ctx.respond(\"pong\", ephemeral=True)\n\nbot.run(data[\"token\"])\n\n```",
    "tags": "專題 ",
    "date": "2025-05-22"
  },
  {
    "id": 10,
    "title": "RL期末專題_貪吃蛇",
    "content": "# RL 期末專題\n>[github 連結](https://github.com/sarah21392773/AI/tree/main/Snake_RL)\n---\n\n## 壹、問題敘述\n\n### ● 選用環境\n\n使用 Pygame 自製的「貪吃蛇」遊戲，改造成類似 gymnasium 格式的強化學習環境，新增了 `reset()`、`play_step(action)`、`is_collision()` 等函式。\n\n### ● 遊戲目標\n\n操控貪吃蛇在不碰撞的情況下吃紅點以獲高分。\n\n### ● 狀態空間\n\n11 維布林值向量（使用 one-hot encoding）代表：\n\n* 危險判斷：`danger_straight`, `danger_right`, `danger_left`\n* 當前方向：`move_left`, `move_right`, `move_up`, `move_down`\n* 食物方向：`food_left`, `food_right`, `food_up`, `food_down`\n\n例如：\\[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1]\n\n### ● 動作空間\n\n使用 one-hot encoding 表示三種離散動作：\n\n* \\[1, 0, 0]：直行（什麼都不做）\n* \\[0, 1, 0]：向右轉（順時針）\n* \\[0, 0, 1]：向左轉（逆時針）\n\n### ● 獎勵機制\n\n| 情況    | 獎勵值 | 說明      |\n| ----- | --- | ------- |\n| 吃到食物  | +10 | 鼓勵      |\n| 撞牆或自撞 | -10 | 處罰      |\n| 其他    | 0   | 正常移動不加分 |\n\n### ● 死亡條件\n\n* 撞牆\n* 撞自己\n* 時間 > 100 x 蛇長\n\n---\n\n## 貳、DQN原理介紹\n\n### ● 探索與利用\n\n使用 \\$ε\\$-greedy 策略平衡探索與利用。\n\n### ● DQN\n\n深度 Q 網路（Deep Q Network）使用神經網路近似 Q 函數，取代傳統 Q-Table。\n\n### ● Replay Buffer\n\n儲存 `(state, action, reward, next_state)` 經驗以提升訓練效率，打亂相關性避免過擬合。\n\n### ● Fixed Q Target\n\n使用兩套網路（current, target）穩定 Q 值學習。\n\n### ● Bootstrapping\n\n用估計去更新同類估計，結合當下與未來的資訊改進策略。\n\n### ● Double DQN\n\n分離動作選擇與評估，降低 Q 值過高估計問題。\n\n### ● Dueling DQN\n\n將 Q 值分為：\n\n* 狀態價值 V(s)\n* 優勢值 A(s,a)\n  使用 \\$Q(s, a) = V(s) + (A(s,a) - \\frac{1}{|A|} \\sum A(s,a'))\\$\n\n### ● Prioritized Experience Replay (PER)\n\n根據 TD 誤差進行經驗抽樣，強化學習效率。\n\n### ● Rainbow-lite DQN\n\n結合 Double DQN、Dueling DQN 和 PER。\n\n---\n\n## 參、研究方法\n\n### 1. 各 DQN 架構\n\n#### ● DQN\n\n* 全連接層：11 → 128 → 64 → 3（對應 3 個動作）\n* 使用 Replay Buffer 與 Fixed Q Target\n\n#### ● Double DQN\n\n* 架構同 DQN\n* 使用 model 選擇動作，target\\_model 計算 Q 值\n\n#### ● Dueling DQN\n\n* 架構分為：Value 分支（輸出 V）、Advantage 分支（輸出 A）\n* 合併公式如前所述\n\n#### ● PER DQN\n\n* 架構同 DQN\n* 使用 TD error 作為抽樣依據，加上 IS 修正權重\n\n#### ● Rainbow-lite DQN\n\n* 架構綜合上述三者\n\n### 2. 模型訓練比較\n\n* 所有模型共通參數：\n\n  * \\$γ=0.9\\$\n  * lr=0.001\n  * eps\\_low=0.05\n  * N\\_EPISODES=1000\n\n---\n\n## 肆、研究結果與分析\n\n| 演算法          | 最高分   | 最終收斂  | 特性描述             |\n| ------------ | ----- | ----- | ---------------- |\n| DQN          | \\~150 | \\~125 | 緩慢穩定             |\n| Double DQN   | \\~150 | \\~125 | 初期佳，後期不穩         |\n| Dueling DQN  | \\~135 | \\~125 | 變異大，效果最差         |\n| PER DQN      | \\~160 | \\~140 | 穩定最佳模型           |\n| Rainbow-lite | \\~150 | \\~125 | 初期成長快，後期與 DQN 相近 |\n\n* 所有模型在 600 回合後表現下降，疑似過擬合。\n\n---\n\n## 伍、討論與心得\n\n1. 更具體理解 DQN 相關理論與實作。\n2. 環境設計需避免讓 agent 原地打轉，但過於限制可能造成後期困難。\n3. 仿 gymnasium 設計仍待補全（如 render 函式）。\n4. Rainbow-lite 效果不如預期，未來可試完整 Rainbow DQN 或調參。\n\n---\n\n## 陸、參考資料\n\n* StackOverflow: Mini-Batches in RL. [https://stackoverflow.com/questions/53864434/mini-batches-in-rl](https://stackoverflow.com/questions/53864434/mini-batches-in-rl)\n* Medium: N-Step Bootstrapping in RL. [https://medium.com/@amit25173/n-step-bootstrapping-in-reinforcement-learning-e4f70f264933](https://medium.com/@amit25173/n-step-bootstrapping-in-reinforcement-learning-e4f70f264933)\n* 博客園: Prioritized Replay DQN. [https://www.cnblogs.com/pinard/p/9797695.html](https://www.cnblogs.com/pinard/p/9797695.html)\n* 博客園: DQN 系列介紹. [https://www.cnblogs.com/jiangxinyang/p/10112381.html](https://www.cnblogs.com/jiangxinyang/p/10112381.html)\n* 掘金: Rainbow DQN. [https://juejin.cn/post/7327723045287559205](https://juejin.cn/post/7327723045287559205)\n* CSDN: 自定義強化學習環境. [https://blog.csdn.net/weixin\\_41434829/article/details/139204435](https://blog.csdn.net/weixin_41434829/article/details/139204435)\n* 成果影片: [https://drive.google.com/file/d/14i73H42KfBccfzgJtc4\\_VZZU\\_HrZJ6r3/view?usp=sharing](https://drive.google.com/file/d/14i73H42KfBccfzgJtc4_VZZU_HrZJ6r3/view?usp=sharing)",
    "tags": "專題 ,AI ",
    "date": "2025-07-01"
  },
  {
    "id": 11,
    "title": "TOI 潛力組 k715. 糧食便道 (Supply)",
    "content": "# TOI 潛力組 k715. 糧食便道 (Supply)\n\n*  題目連結：<br/>\n&emsp;[在這裏～～](https://zerojudge.tw/ShowProblem?problemid=k715)\n \n---\n\n## **理解題意**\n\n---\n\n### 目標\n有 `N` 個城鎮，其中 `K` 個城鎮有糧食。建立道路(共有 `M` 條路可供選擇)，**讓每個城鎮至少連接到一個有糧食的城鎮**，而且總成本最小。\n\n* 範例:\n![螢幕擷取畫面 2025-08-03 005308](https://hackmd.io/_uploads/HJnKG6jvge.png)\n\n\n    * 輸入: 有 N = 8 個城鎮，編號 1 至 8。城鎮 3 以及城鎮 8 有生產糧食 (星星)。\n    * 輸出: 10 (如圖二)\n    \n---    \n    \n## 解題\n\n---\n### 解題思路\n1. 用 `struct` 結構紀錄道路的兩端與成本，提高可讀性與操作方便。\n2. 為了避免額外標記「誰有糧食」的麻煩，**引入虛擬原點（編號 0）**，且其與「有糧食的城市」邊權為 0。\n3. 對所有邊（包含虛擬邊）進行 `Kruskal 最小生成樹演算法`，總成本即為所求。\n\n:::danger \n! ! ! 解題關鍵:<br/>單純用 **Kurkal + 森林** 只能確保所有城市用最小成本相連，但**不能確保每棵樹都有糧食原點**。所以應該加入`虛擬原點`。\n:::\n![88237f00-ff3c-4343-b4d6-ad28d6d857df](https://hackmd.io/_uploads/rJ8ozrnDle.jpg)\n\n\n### 程式碼\n\n```c++=\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\n\n\nstruct Road{\n    int left, right, weight;\n    bool operator<(const Road& r) const{\n        return weight < r.weight;\n    }\n};\n\nint N, M, K, ans;\nvector<int> root, sz;\npriority_queue<int> pq;\n\nint Find(int a){\n    if(root[a] == a) return a;\n    return root[a] = Find(root[a]);\n}\n\nbool Union(int a, int b){\n    a = Find(a), b = Find(b);\n    if(a == b) return false;\n    if(sz[a] > sz[b]) swap(a, b);\n    sz[b] += sz[a];\n    root[a] = Find(b);\n    return true;\n}\n\nint main(){\nios::sync_with_stdio(false);cin.tie(0);\n    // initial\n    cin >> N >> M >> K;\n    vector<Road> roads;\n    sz.assign(N+1, 1);\n    root.assign(N+1, 0);\n    iota(all(root), 0);\n    // invisible plot 0 (weight = 0)\n    int temp;\n    for(int i=0; i<K; i++){\n        cin >> temp;\n        roads.push_back({0, temp, 0});\n    }\n    // input the roads\n    int a, b, c;\n    for(int i=0; i<M; i++){\n        cin >> a >> b >> c;\n        roads.push_back({a, b, c});\n    }\n    // Kruskal\n    sort(all(roads));\n    for(auto & r:roads){\n        if(Union(r.left, r.right))\n            ans += r.weight;\n    }\n    cout << ans << \"\\n\";\nreturn 0;\n}\n```\n\n### 補充\n\n* iota() 用法\n    * 目的:<br/>將陣列填入遞增元素\n    * 語法:<br/>`iota(arr.begin(), arr.end(), 開始元素)`\n    \n    * 範例:\n        arr[6] = {}\n        輸入: `iota(arr.begin(), arr.end(), 0)`\n        輸出: 0 1 2 3 4 5<br/>\n\n* 最小生成樹\n    [觀念](https://hackmd.io/@konchin/MST)\n\n\n---\n## 廢話區\n---\nya!",
    "tags": "競程 ,TOI ",
    "date": "2025-07-13"
  },
  {
    "id": 12,
    "title": "第65屆高雄市科展 -- RL_CarRacing",
    "content": "# 🏎️ RL_CarRacing\n\n## 科展專題：應用強化學習與生成網路於自動駕駛訓練\n> 作者: 吳苡柔、黃品薰、郭依瑾　　指導老師: 邱崑山、段雅培\n\n> [github 連結](https://github.com/sarah21392773/AI/tree/main/CarRacing_RL)\n\n### 📌 專題簡介\n\n本研究以 **OpenAI Gym CarRacing** 環境為平台，探討如何利用 **深度強化學習 (Deep Reinforcement Learning)** 及 **生成式模型 (AE/VAE)** 來訓練自動駕駛代理人。\n透過不同演算法、感知方式及獎勵機制的比較，分析其對模型表現與學習效率的影響，期望能找到更穩定且高效的自動駕駛訓練方式。\n\n---\n\n### 🎯 研究動機\n\n* 2025 CES 展示了自動駕駛的未來潛力，啟發我們探索其實現方式。\n* 強化學習可透過「嘗試錯誤」讓智能體學會駕駛決策。\n* 我們希望結合 **DQN 改進演算法** 與 **生成式 AI (AE/VAE)**，提升自動駕駛智能體的穩定性與表現。\n\n---\n\n### ⚙️ 研究方法\n\n1. **演算法實驗**\n\n   * DQN\n   * Double DQN\n   * Dueling DQN\n\n2. **探索策略**\n\n   * ε-greedy 演算法\n   * 不同 ε 衰減策略比較\n\n3. **環境改寫**\n\n   * 裁切影像：96×96 → 84×84 → 72×72\n   * 修改獎勵機制：鼓勵車輛保持賽道中央\n   * Replay Buffer 改進：由均勻採樣 → 步數加權採樣\n   * 增加「出界即終止」條件，模擬真實駕駛環境\n\n4. **感知 AI 實驗**\n\n   * 使用不同觀測空間：空照圖、車前影像、感知融合\n   * 加入生成式 AI：\n\n     * AE (AutoEncoder)\n     * VAE (Variational AutoEncoder)\n\n---\n\n### 🖥️ 實驗設備\n\n* **硬體**：Nvidia Jetson Orin 16GB\n* **軟體**：Python 3.10、PyTorch、Google Colab\n\n---\n\n### 📊 研究結果\n\n1. **演算法比較**\n\n   * Dueling DQN > DQN > Double DQN\n   * Dueling DQN 收斂較快，表現最穩定。\n\n2. **探索策略**\n\n   * 衰減係數 x=5 表現最佳。\n   * 適度探索 + 收斂能平衡學習速度與最終表現。\n\n3. **獎勵機制**\n\n   * 修改後能加快前期學習速度，提升探索效率。\n\n4. **感知方式**\n\n   * 車前影像比空照圖更接近真實，初期學習更快，但後期表現略不穩定。\n   * 感知融合未優於單一輸入，可能因環境過於簡單。\n\n5. **生成式 AI 輔助**\n\n   * VAE 效果優於 AE，泛化能力較強。\n   * AE/VAE 在探索期能加快學習，但貪婪階段表現略差。\n\n6. **Replay Buffer 改進**\n\n   * 「步數加權採樣」能改善出界即終止所造成的早期重複學習問題。\n\n---\n\n### 📌 結論\n\n* **最佳演算法**：Dueling DQN\n* **最佳探索策略**：ε 衰減係數 = 5\n* **最佳獎勵設計**：以賽道中央為基準修正獎勵\n* **生成式 AI**：VAE 較有潛力提升泛化性\n* **改進方向**：\n\n  * 增加真實模擬環境複雜度\n  * 探索連續動作空間的演算法（如 DDPG, SAC）\n  * 加入緩衝區設計，提升安全性與補救能力\n\n---\n\n### 📎 參考文獻\n\n* Mnih et al. (2015). *Human-level control through deep reinforcement learning*. Nature.\n* Wang et al. (2016). *Dueling Network Architectures for Deep Reinforcement Learning*. arXiv.\n* Sutton & Barto. *Reinforcement Learning: An Introduction*.\n* 其他參考來源包含 Medium、IBM、Udacity 等。\n\n---\n> 獲得高雄市第65屆科展_資訊組，團體合作獎",
    "tags": "專題 ,AI ",
    "date": "2025-04-26"
  }
]
