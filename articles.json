[
  {
    "id": 2,
    "title": "APCS b966. 3. 線段覆蓋長度",
    "content": "# **APCS b966. 3. 線段覆蓋長度**\n\n*  題目連結：<br/>\n&emsp;[在這裏～～](https://zerojudge.tw/ShowProblem?problemid=b966)\n \n---\n\n## **理解題意**\n\n---\n### 目標\n給定N段線段的起點和終點，輸出線段覆蓋長，重疊的部分只能算一次\n### 範例\n![ShowImage](https://hackmd.io/_uploads/BJ2h1j0yA.png)\n* 輸入: 給4段線段長(N=4)，起點與終點分別為(5,6)、(1,2)、(4,8)、(7,9)\n* 輸出: 被覆蓋區域有(1,2)、(4,9)，共6線段長。\n---    \n    \n## 解題\n\n---\n### 解題思路\n1. 用pair結構紀錄線段的起點與終點，使程式的可讀性更高。\n2. 設一個pair一維陣列，用來記錄每一線段長。\n3. 將線段依起點數值由小到大排序。\n4. 記錄上一線段長的起點位置，用來和下一線段作比較。\n5. 判斷線段狀況，並根據每一種情況，做運算。\n6. 若為狀況一:覆蓋線段長+線段B長度\n7. 若為狀況二:覆蓋線段長+線段B終點-線段A起點\n8. 若為狀況三:覆蓋線段長不變\n:::danger \n! ! ! 解題關鍵:\n&emsp;將線段先依起點數值由小到大排序(用sort函式)，就可以確保相鄰兩線段關係只有以下三種狀況。\n:::\n* 狀況一: 線段A、B不重疊\n![IMG_0292](https://hackmd.io/_uploads/rkDY8oA1R.jpg)\n* 狀況二: 線段A後半段重疊線段B前半段\n![IMG_0293](https://hackmd.io/_uploads/S1ARLi0yC.jpg)\n* 狀況三: 線段A涵蓋線段B(兩線段完全重疊)\n![IMG_0294](https://hackmd.io/_uploads/SJW7voRk0.jpg)\n#### 排序示意圖:\n* 排序前:\n![IMG_0290](https://hackmd.io/_uploads/Bya-Vs01R.jpg)\n* 排序後:\n![IMG_0291](https://hackmd.io/_uploads/Sy7fVi0JR.jpg)\n\n### 程式碼\n\n```c++=\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\n    int N;          //共有N個線段\n    cin >> N;\n    pair<int,int> line[N];  //用pair結構建立一維陣列，紀錄線段起點和終點\n    for(int i=0;i<N;i++){\n        cin >> line[i].first >> line[i].second;\n    }\n    sort(line,line+N);      //將線段依起點數值大小排序(由小到大)\n    int right=line[0].second,ans=right-line[0].first;   //right為上一線段終點,ans是線段覆蓋長度\n    for(int i=0;i<N-1;i++){     \n        if(line[i+1].second>right){   //若線段不完全包含在上一線段內\n            if(line[i+1].first<right) ans+=line[i+1].second-right;  //若前半部重疊，ans加上為重疊部分長\n            else ans+=line[i+1].second-line[i+1].first;  //若完全不重疊，ans加上新的線段長\n        }\n        right=max(line[i+1].second,right);      //更新尾巴數值\n    }\n    cout << ans;\n    \nreturn 0;\n}\n```\n\n### 新的酷東西\n\n* pair用法\n    <br/>\n    * 個人理解:\n        &emsp;pair就是struct結構的簡略版。\n        &emsp;差別在於pair只能有兩個參數(資料型態)，而struct可有多個。\n        &emsp;若只有要用兩個參數，使用pair會比較方便，因為struct要自己寫，但pair不用。\n        \n    * 語法:\n        1. 宣告變數:\n            &emsp;&emsp;pair <資料型態,資料型態> 變數名稱\n        2. 呼叫變數:\n            &emsp;&emsp;變數名稱.first  (第一個)\n            &emsp;&emsp;變數名稱.second (第二個)\n    \n    * 範例:\n        1. 程式碼:\n        &emsp;&emsp;pair <string,float> A;\n        &emsp;&emsp;cin >> A.first >> A.second;\n        &emsp;&emsp;cout << A.first << \" : \" << A.second+10;\n        2. 輸入:\n        &emsp;&emsp;HowLong 20\n        3. 輸出:\n        &emsp;&emsp;HowLong : 30\n\n---\n## 廢話區\n---\n\n阿阿阿~終於解出來了!\n我覺得這一題很有難度，看到這題目時，我腦袋裡只有好多會TLE的想法，對於時間複雜度較低的解法，完全沒想法:sweat_smile:。\n有辦法解出這題，其實是偷了佩雯上課時提供的想法，哈哈~\n然後，我很訝異，我居然有辦法解出APCS第三題了ㄟ! (之前程度都只停留在第二題，雖然這題也是花了我好幾小時啦~)",
    "tags": "競程 ,APCS ",
    "date": "2024-04-06"
  },
  {
    "id": 3,
    "title": "a007. 判斷質數",
    "content": "# **a007. 判斷質數**\n\n*  題目連結：<br/>\n&emsp;[在這裏～～](https://zerojudge.tw/ShowProblem?problemid=a007)\n \n---\n\n## **理解題意**\n\n---\n\n### 目標\n判斷某數是否為質數，若為質數，輸出\"質數\";否則輸出\"非質數\"。\n* 範例:\n    * ( 一 ) 輸入:13 輸出:質數 \n    * ( 二 ) 輸入:18 輸出:非質數\n    \n---    \n    \n## 解題\n\n---\n### 前言\n先來講講我TLE的解法，我的作法是用自定義函式`is_Prime`來判斷n是否為函數。然後函式裡的邏輯就是讓n除以2~$\\sqrt{n}$ 的數，如果n能被整除，n就不會是質數，否則就代表n的因數只有1和自己，n就是質數。但這種作法，相當於每遇一數就要從2開始，一數一數檢查到$\\sqrt{n}$，在有多筆測資的情況下相當耗時，因此應該要先建一個質數表(只需要算一次)，之後的數字在用這個質數表作判斷。\n\n### TLE 程式碼\n\n```c++=\n#include<bits/stdc++.h>\nusing namespace std;\n\nstring is_Prime(int n){\n    int i=2;        //i是因數\n    while(i*i<=n){    //當i<=根號n時\n        if(n%i==0){    //若n能被i整除\n            return \"非質數\\n\";    //n就不是質數\n        }\n        i++;\n    }\n    return \"質數\\n\";    //若n都不能被小於根號n的數整除，n就是質數\n}\n\nint main(){\n    int n=0;        //判斷n是否為質數\n    while(cin >> n) cout << is_Prime(n);  //用自訂函式判斷n是否為質數\nreturn 0;\n}\n```\n\n### AC解題思路\n1. 因為要使用`sqrt()`，所以引入`<cmath>`函式庫。\n2. 用優化器減少TLE的機會。\n3. 建一個質數表，減少程式執行時間(才不用每次都從2開始，一數一數檢查)。\n4. 要判斷n是否為質數，只要用n除質數表中的數字即可。\n:::danger \n! ! ! 注意:\n&emsp;這題要#include\\<iostream>，不要#include<bits/stdc++.h>，不然很容易TLE。\n:::\n\n\n### AC程式碼\n\n```c++=\n#include <iostream>\n#include <cmath>    //要用sqrt要include<cmath>\nusing namespace std;\nint main(){\n\tios_base::sync_with_stdio(0);       //聽說這叫優化器\n\tcin.tie(0);\n\tint prime[5000],t=0; //prime[5000]是2~2147483647中的質數,t是質數表中的索引 \n\tbool b=1;   //若b=1，就代表是質數\n\tfor(int i=2;i<=sqrt(2147483647);i++){    \n\t\tb=1;\n\t\tfor(int j=2;j<=sqrt(i);j++){\n\t\t\tif(i%j==0){     //若i能被j整除，就不是質數\n\t\t\t\tb=0;\n\t\t\t\tbreak;\n\t\t\t}\t\t\n\t\t\t\n\t\t}\n\t\tif(b) prime[t++]=i;//若i是質數，就加入質數表\n\t}\n\t\n\tint n;      //判斷n是否為質數\n\twhile(cin>>n){\n\t\tb=1;    //若b=1，就代表是質數\n\t\tfor(int i=0;i<t;i++){   \n\t\t\tif(sqrt(n)<prime[i]) break; //若質數表中的數已經比根號n大，n就是質數\n\t\t\tif(n%prime[i]==0){  //若n能被質數表中的數整除\n\t\t\t\tb=0;            //n就不是質數\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(b) cout<<\"質數\"<<endl;\n\t\telse cout<<\"非質數\"<<endl; \n\t\t\n\t}\n\treturn 0;\n}\n```\n\n\n\n### 新的酷東西\n\n* i/o 優化\n    * 目的:\n        &emsp;降低程式TLE的機會\n        \n    * 原理:\n        &emsp;在文字被輸出前，它會先到一個「緩衝區」，不是馬上就全部輸出，而是到一個特定的時間再一次輸出出去，因為分次輸出其實算是很耗資源的事。強制將緩衝區的資料釋放（輸出）的動作稱為 `flush`。在 `iostream`，這個動作是 `cout << flush`。緩衝區的釋放是決定效率的關鍵因素，看是一次釋放、還是多次釋放，速度就會大有不同。\n       `cin` 會強制釋放，因為在要求使用者輸入之前，應該先讓使用者看見先前輸出的文字，這是介面設計上的考量，但顯然不符合競程的需要，因此我們要取消強制釋放。\n\n    :::info \n    :bulb:tip:\n     `endl` 也會自動 `flush`，也就是說，`cout << endl` 其實是 `cout <<      flush << '\\n' `，想解決此問題，只要改用`cout << '\\n' `就可以了。\n    :::\n    \n    * 語法:\n        &emsp;取消強制釋放：`cin.tie(0)`;\n        &emsp;解除 `iostream` 和 `stdio` 同步: `ios_base::sync_with_stdio(false)`;\n        \n    * 資料參考: [點我看更多](https://hackmd.io/@wiwiho/CPN-io-optimization)\n\n\n---\n## 廢話區\n---\n\n剛開始看到這題目，我想說怎麼又是判斷質數，然後我自信滿滿的寫了一個比之前都還要短、簡潔明瞭的程式，結果居然TLE。所以我只好換另一種解法(也就是建質數表)，這種方式好像比較直觀，但我不知道為什麼，第一想法居然不是這個，或許是之前解題經驗關係吧? \n(雖然但是，我認真覺得我 TLE 的程式碼比較漂亮。:point_right::point_left:)",
    "tags": "競程",
    "date": "2024-04-08"
  },
  {
    "id": 4,
    "title": "APCS f580. 2.骰子",
    "content": "# **APCS f580. 2.骰子**\n\n*  題目連結：<br/>\n&emsp;[在這裏～～](https://zerojudge.tw/ShowProblem?problemid=f580)\n \n---\n\n## **理解題意**\n\n---\n\n### 操作方式\n* 將骰子向前轉(b=-1)\n![IMG_0281](https://hackmd.io/_uploads/Hyo2KyHyA.jpg)\n* 將骰子向右轉(b=-2)\n![IMG_0285](https://hackmd.io/_uploads/BJO2Xd8JC.jpg)\n* 交換兩顆骰子(a、b都是正數)\n![IMG_0283](https://hackmd.io/_uploads/SkFwoJrJR.jpg)\n### 目標\n全部操作完後，依序輸出每顆骰子頂部的點數\n* 範例:\n![IMG_0284](https://hackmd.io/_uploads/H1CZMgH1C.jpg)\n    * 範例一 輸出: 3 1 \n    * 範例二 輸出: 2 5 6\n    \n---    \n    \n## 解題\n\n---\n### 解題思路\n1. 用struct結構紀錄骰子頂部、前方、右方的點數，使程式的可讀性更高。\n2. 設一個struct一維陣列，用來記錄每一顆骰子狀態。\n3. 若a、b皆為正數，就用swap()交換兩顆骰子。\n4. 若b為-1，就將邊號a的骰子向前旋轉。\n5. 若b為-2，就將邊號a的骰子向右旋轉。\n6. 全部操作完後，依序輸出每顆骰子頂部的點數。\n:::danger \n! ! ! 解題關鍵:<br/>\n&emsp;每一面骰子和對面的點數加給來都是7，所以在翻面的時候，只要用7-目前前方的點數，就能知道新的骰子狀態。\n:::\n* 例如:\n![IMG_0281](https://hackmd.io/_uploads/r1Xs7WHkR.jpg)\n    * 原本前方是4，右方是2，頂部是1，將骰子向前轉後，前方變成1 (原本的頂部)，右方是2 (不變)，頂部變成3 (7-原本前方點數4)。\n\n\n### 程式碼\n\n```c++=\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct TheDice{     //struct紀錄骰子頂部、前方和右方的點數\n    int top=1,right=2,infront=4;    //設定初始值\n};\n\nint main(){\n    int n,m;            //n是骰子數，m是操作次數\n    cin >> n >> m;\n    TheDice dice[n];    //陣列儲存每顆骰子的狀態\n    for(int i=0;i<m;i++){\n        int a,b;        //a為要被操作的骰子編號，b是操作動作\n        cin >> a >> b;\n        if(b>0){        //若b為正數，則交換編號a和編號b的骰子\n            swap(dice[a-1],dice[b-1]);\n        }\n        else if(b==-1){ //若b為-1，邊號a的骰子向前旋轉\n            int tem=dice[a-1].infront;\n            dice[a-1].infront=dice[a-1].top;\n            dice[a-1].top=7-tem;\n        }\n        else{           //若b為-2，邊號a的骰子向右旋轉\n            int tem=dice[a-1].right;\n            dice[a-1].right=dice[a-1].top;\n            dice[a-1].top=7-tem;\n        }\n    }\n    for(int i=0;i<n;i++){   //輸出每顆骰子頂部的點數\n        cout << dice[i].top << \" \";\n    }\n    cout << endl;\nreturn 0;\n}\n```\n\n### 新的酷東西\n\n* swap用法\n    * 目的:<br/>\n        &emsp;交換兩個變數的值\n    * 語法:<br/>\n        &emsp;swap(a,b)\n    * 範例:<br/>\n        &emsp;(一.)<br/>\n        &emsp;&emsp;若 a=5 ， b=10<br/> \n        &emsp;&emsp;swap(a,b)<br/>\n        &emsp;&emsp;a=10 b=5<br/>\n        &emsp;(二.)<br/>\n        &emsp;&emsp;若 arr[0]='a' , arr[1]='b'<br/>\n        &emsp;&emsp;swap(arr[0],arr[1])<br/>\n        &emsp;&emsp;arr[0]='b' arr[1]='a'<br/>\n\n\n---\n## 廢話區\n---\n\n這一題我想很久，終於想出來怎麼寫了，我很開心，所以特地為它寫了這篇，哈哈~<br/>\n我覺得這一題的程式碼不會太難，主要是難在該怎麼判斷骰子前後左右點數是什麼，這一點我找很久才找到。一開始，我一直在觀察骰子的相鄰兩面有沒有什麼規律，是相加為一定數?相乘是定值?還是相差一樣的數字，但都找不到關聯性。後來因為段考後閒閒沒事做，直接拿了實體骰子起來看，東翻翻，西轉轉，終於被我看出來了!我發現骰子每面和對面的點數和是7，只要觀察出這點，之後很快就把程式寫出來啦!",
    "tags": "競程 ,APCS ",
    "date": "2024-04-17"
  },
  {
    "id": 5,
    "title": "Unity 筆記",
    "content": "# Debug\nDebug.Log(123); //consolon print 123\n\n# move\n* transform.Translate(1,0,0); //x,y,z\n* transform.Translate(1,0.1f,0); //only float not double, so press f\n* transform.Translate(0,0.01f*Time.deltaTime,0); //press Time.deltaTime to avooid each computer runtime not same\n# add someting in inspecter\n* [SerializeField] float moveSpeed = 5f; //[SerializeField] -> gobal and can change in inspecter\n# dectect communite\n### press keyborad?\n* Input.GetKey(KeyCode.RightArrow)\n* Input.GetKey(KeyCode.LeftArrow)\n* Input.GetKey(KeyCode.upArrow)\n* Input.GetKey(KeyCode.downArrow)\n* Input.GetKey(KeyCode.A)\n\n# Rigidbody 2D\n* inspecter -> Add Component -> Rigidbody 2D\n* There are mass and gravity etc like reallife\n* Constraints -> Freeze Rotation 打勾可使他不旋轉\n\n# 碰撞?\n* inspecter -> Add Component -> collider\n* squere -> Box Collider 2D(3D)\n* circle -> Circle Collider 2D(3D)\n* add tag to hierarchy and than you can coding!\n```C#= \nvoid OnCollisionEnter2D(Collision2D other) {\n        if(other.gameObject.tag == \"Floor1\"){\n            Debug.Log(\"ㄚㄚㄚ\");\n        }\n        else if(other.gameObject.tag == \"Floor2\"){\n            Debug.Log(\"2222\");\n        }\n    }\n```\n* other.contacts[0].point -> 取得角色碰撞點座標位置\n* other.contacts[0].normal -> 取得角色碰撞法向量座標位置\n\n# is Tigger\n* inspecter -> Box collider -> is Tigger [V] only Dectect not 碰撞\n* 把OnCollisionEnter2D改成OnTriggerEnter2D\n```C#=\n    void OnTriggerEnter2D(Collider2D other)\n    {\n        //經過時執行\n        if(other.gameObject.tag == \"DeathLine\"){\n            Debug.Log(\"WA\");\n        }        \n    }\n```\n\n# 角色圖層\n* Sprite Renderer -> Additional Settings -> Order in Layer (more number it is, much award)\n* 可以把角色做成模板(prefab)。把角色拉到Assets即可。要用的時候從Assets拉到畫面即可。\n* Prefab就可以一次改變顏色、尺寸等等\n\n# UI\n* UI中的canva下的子物件，可蓋過所有遊戲畫面",
    "tags": "專題 ",
    "date": "2024-08-25"
  },
  {
    "id": 6,
    "title": "強化學習_CartPole小提示",
    "content": "# CartPole 小提示\n### Space?\n* state\n  * state[0] -> Cart Position\n  * state[1] -> Cart Velocity\n  * state[2] -> Pole Angle\n  * state[3] -> Pole Angular Velocity\n* action\n  * action=0 -> Push cart to the **==left==**\n  * action=1 -> Push cart to the **==right==**\n### 目標?\n* 不要讓桿子倒下，撐越久越好\n### 邏輯?\n* 我有用到state[0]、state[2]、state[3]\n* 先判斷桿子的角度和速度(角度和速度不能太大)\n* 再判斷車子的位置(盡量讓車子在中間)\n> 不要問我怎麼知道的，我就是一直~~亂試~~\n### 實作\n:::spoiler\n```py=\ndef Policy(state):\n    if state[2]>0.08 or state[3]>0.6:\n      action=1\n    elif state[2]<-0.08 or state[3]<-0.6:\n      action=0\n    else:\n      if state[0]<0:\n        action=0\n      else:\n        action=1\n    return action\n```\n:::\n### 成果?\n* 它看起來搖搖欲墜(~~跟我的精神狀態一樣~~)，但它確實是500分\n\n{%youtube aaUQPH62V2w %}\n\n* 有看不懂的再來問我😊",
    "tags": "專題 ,AI ",
    "date": "2024-09-15"
  },
  {
    "id": 7,
    "title": "關於 github 資料夾",
    "content": "# 關於 github 資料夾\n\n## 上傳\n\n### 先到github右上角的+，點New repository\n![螢幕擷取畫面 2024-10-18 213903](https://hackmd.io/_uploads/S16N8keeyx.png)\n### 輸入專案名稱，並選擇公開或私人\n![螢幕擷取畫面 2024-10-18 213944](https://hackmd.io/_uploads/rJwrIyllJl.png)\n### 在本機cmd，移動到要上傳的資料夾路徑\n``` cd C:\\your\\path```\n### 在cmd輸入以下指令\n``` \ngit add .\ngit commit -m \"Initial commit\"\n```\n### 接著回到github，複製這三行指令到cmd\n![螢幕擷取畫面 2024-10-18 215034](https://hackmd.io/_uploads/H1XGdyleJx.png)\n### 好耶!完成了\n![螢幕擷取畫面 2024-10-18 215521](https://hackmd.io/_uploads/H19Wtyleyg.png)\n\n## 下載\n### 在cmd中打這一行，就可以下載下來\n```\ngit clone github資料夾網址.git\n```\n### 如果想把修改後的資料夾再上傳到github\n```\ngit add .\ngit commit -m \"變更訊息\"\ngit push origin main\n```",
    "tags": "專題 ",
    "date": "2024-10-18"
  },
  {
    "id": 8,
    "title": "APCS CAMP 筆記",
    "content": "# 目標 演算法 : 57題 (已完成27題)\n\n# 區間DP、雙指針不懂\n\n# 作弊long long int法\n寫了 ```#define int long long``` 後再把```int main()```改成```signed main()```。之後程式碼只要寫```int```，他的型態就直接是```long long int```了!\n:::danger\n! 注意 :\n除了APCS、競程，其他情況盡量不要用(例如:寫專案，因為記憶體會爆炸)\n:::\n\n\n# 條件式酷方法\n### (條件 ?  成立執行 : 不成立執行)\n#### 舉例1: 如果a==1就加上5否則等於0\n```c\na+=(a==1 ? 5 : -a);\n```\n#### 舉例2: 如果a>0就輸出a否則輸出0\n```c\ncout << (a>0 ? a : 0);\n```\n### 好酷!\n```c\nans+=sum==m。\n```\n* 如果 ```sum==m```，```ans+=sum```\n\n### 不輸出行尾空白的方法\n```c=\nint a[n+5][m+5]={0};\nfor(int i=0;i<n;i++){\n    for(int j=0;j<m;j++){\n         cout << a[i][j] << \"*\\n\"[j==m-1];   \n    }\n}\n```\n* 若```n=2```，```m=3```。會輸出:\n```\n0*0*0\n0*0*0\n```\n\n* ```\"*\\n\"[j==m-1]```\n如果後面的判斷式是1，就輸出字串索引1的```\\n```，否則輸出字串索引0的```*```\n\n# Vector\n### vector 比大小\n* 從array[0]開始比\n例如:\na={1,2,3}\nb={1,4,3}\n結果 ```b>a```\n因為```a[0]==b[0]```但```a[1]<b[1]```\n\n\n# struct\n感覺struct有點像python裡的class?\n### 奇怪初始化方式\n```c=\nstruct Dog{\n    //初始化(aa的值給a，bb的值給b，cc的值給c)\n    Dog(int aa,int bb,int cc):\n        a{aa},b{bb},c{cc}{\n            //可以放程式碼也可以不放(會在初始化後執行)\n            cout << \"hi\\n\";\n        }\n    //struct的變數\n    int a,b,c;\n};\n```\n* ```Dog dog(2,5,7)``` 就可以初始化dog的a、b、c\n### 結構函式\n```c=\nstruct Dog{\n    void say(){\n        cout << \"hi\";\n    }\n};\n```\n* ```dog.say()``` 就可以輸出\"hi\"\n\n\n# 時間複雜度\n### O(10^8~10^9)大約會執行1秒\n* ```sort(arr,arr+n)``` -> O(n log n)\n* ```log(n)``` -> O(n)\n* 遍歷 -> O(n)\n* max_element() -> O(n)\n:::info\n! 小提醒 :\nvector雖然push只有O(e)，但insert()需要把所有資料往後平移，所以可能會TLE\n:::\n### ios 優化器\n```c=\ncin.tie(0);\nios::sync_with_studio(false);\n```\n:::danger\n! 注意 : \n加了優化器後， endl 都要改成 \"\\n\" 才會達到優化效果。\n:::\n\n\n# DSU\n### 路徑壓縮:只要知道點屬於哪個集合(例如:~~我知道我的未來不是夢~~。我知道A屬於B，但不需知道B的父節點是A)\n## 常用於合併、集合問題\n```C\n\n```\n\n\n# 位元枚舉\n### 例如:用二進位，表示狀態?\n* 20=2*(10\\^1)\n* 40=4*(5\\^1)\n* 202=2*(3\\^2)+2*(3\\^0)\n### 10進位轉換成k進位\n先取模再除k。\n#### 舉例：20 轉到三進位的步驟如下：\n1. ```20 % 3 = 2```，```20 / 3 = 6```，右放到左：2\n2. ```6 % 3 = 0```，```6 / 3 = 2```，右放到左：02\n3. ```2 % 3 = 2```，```2 / 3 = 0```，右放到左：202\n4. 要固定長度就執行到第 n 點 (一直在前面補 0)，不用的話就結束了\n### k 進位轉到 10 進位的方法，就是左取到右，先乘再加重複 n 次\n#### 舉例：三進位的 202 轉成十進位的步驟如下\n1. 左取到右：2，```ans ≔ ans×3 + 2```，ans = 2\n2. 左取到右：0，```ans ≔ ans×3 + 0```，ans = 6\n3. 左取到右：2，```ans ≔ ans×3 + 2```，ans = 20\n\n# 貪心\n### 硬幣問題\n* 只有==一個面額==或面額都成==倍數關係==，就可以做貪心。\n\n# 圖論\n### 存圖(用vector存)\n* graph[節點].push_back( {連接的節點,邊權} )\n* {連接的節點,邊權}是一個pair\n* W[節點][點權]\n### DFS\n#### 計算連通塊數量\n* 枚舉每個點進行DFS。看總共DFS幾次就知道有幾塊連通塊。\n\n# 分治\n### 合併排序\n```cpp=\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nvector<int> arr={5,3,8,6,2,7,1,4};\n\n//排序\nvoid Merge(int start,int arr_end,int mid){\n    vector<int> LeftArr(arr.begin()+start,arr.begin()+mid+1);\n    vector<int> RightArr(arr.begin()+mid+1,arr.begin()+arr_end+1);\n    LeftArr.push_back(LLONG_MAX);\n    RightArr.push_back(LLONG_MAX);\n    int Left_id=0,Right_id=0;\n    for(int i=start;i<=arr_end;i++){\n        if(LeftArr[Left_id]<=RightArr[Right_id]){\n            arr[i]=LeftArr[Left_id];\n            Left_id++;\n        }\n        else{\n            arr[i]=RightArr[Right_id];\n            Right_id++;\n        }\n    }\n}\n\n//分割\nvoid Merge_sort(int start,int arr_end){\n    if(start < arr_end){\n        int mid=(start+arr_end)/2;\n        Merge_sort(start,mid);\n        Merge_sort(mid+1,arr_end);\n        Merge(start,arr_end,mid);\n    }\n}\n\nsigned main(){\n    Merge_sort(0,7);\n    for(auto &i:arr) cout << i << \" \";\nreturn 0;\n}\n\n```\n\n\n# 雜七雜八\n### (int) arr.size()\n如果用.size()，盡量養成(int)的習慣。才不會被轉成unsigend long long，然後溢位。\n\n### const auto &i:v\n* 不加&就是要把v裡面的值都在複製一次。但加了&就是直接把v裡面的值叫出來，可以讓時間減少。\n* 加了const就可以避免原數值被改掉\n\n\n# 上課影片\n* [APCS Camp 2024 8/12 (一) 上午 錄影紀錄](https://www.youtube.com/watch?v=EvPJpGA5B9g)\n* [APCS Camp 2024 8/12 (一) 下午 錄影紀錄](https://www.youtube.com/watch?v=9BGI6J1KYr0)\n* [APCS Camp 2024 8/13 (二) 上午 錄影紀錄](https://www.youtube.com/watch?v=ZchQIcdOPbM)\n* [APCS Camp 2024 8/13 (二) 下午 錄影紀錄](https://www.youtube.com/watch?v=CB3N6v372LU)\n* [APCS Camp 2024 8/14 (三) 上午 錄影紀錄](https://www.youtube.com/watch?v=07Hxnm4jmjg)\n* [APCS Camp 2024 8/14 (三) 下午 錄影紀錄](https://www.youtube.com/watch?v=OkiinYa5iK4)\n* [APCS Camp 2024 8/15 (四) 上午 錄影紀錄](https://www.youtube.com/watch?v=HTkW_O1asmo)\n* [APCS Camp 2024 8/15 (四) 下午 錄影紀錄](https://www.youtube.com/watch?v=kyZaHRJPYwk)\n* [APCS Camp 2024 8/16 (五) 上午 錄影紀錄](https://www.youtube.com/watch?v=TQMubmAfpyg)\n* [APCS Camp 2024 8/16 (五) 下午 錄影紀錄](https://www.youtube.com/watch?v=xsPfHfs1QjY)\n* [APCS Camp 2024 8/17 (六) 上午 錄影紀錄](https://www.youtube.com/watch?v=bMkW_uqtbGw)\n* [APCS Camp 2024 8/17 (六) 下午 錄影紀錄](https://www.youtube.com/watch?v=Ab_on7By7aE)\n* [APCS Camp 2024 8/19 (一) 上午 錄影紀錄](https://www.youtube.com/watch?v=8LC2JiOHvWQ)\n* [APCS Camp 2024 8/19 (一) 下午 錄影紀錄](https://www.youtube.com/watch?v=SVmQUc92pkE)\n* [APCS Camp 2024 8/20 (二) 上午 錄影紀錄](https://www.youtube.com/watch?v=qNdVhsR8-ys)\n* [APCS Camp 2024 8/20 (二) 下午 錄影紀錄](https://www.youtube.com/watch?v=IN5v6zV-5lw)\n* [APCS Camp 2024 8/21 (三) 上午 錄影紀錄](https://www.youtube.com/watch?v=uk-Q9P1rcGc)\n* [APCS Camp 2024 8/21 (三) 下午 錄影紀錄](https://youtu.be/jdDR4iUhuco)\n* [APCS Camp 2024 8/22 (四) 上午 錄影紀錄](https://www.youtube.com/watch?v=lYkHlMzqy6g)\n* [APCS Camp 2024 8/22 (四) 下午 錄影紀錄](https://www.youtube.com/watch?v=pssCJ_tfRRQ)\n* [APCS Camp 2024 8/23 (五) 上午 錄影紀錄](https://www.youtube.com/watch?v=DrthOBqMyIU)\n* [APCS Camp 2024 8/23 (五) 下午 錄影紀錄](https://www.youtube.com/watch?v=MR0tcrm0RMc)\n* [APCS Camp 2024 8/24 (六) 上午 錄影紀錄](https://www.youtube.com/watch?v=QYysXYtAvB8)\n* [APCS Camp 2024 8/24 (六) 下午 錄影紀錄](https://www.youtube.com/watch?v=Ljc7vNdXymw)",
    "tags": "競程 ",
    "date": "2024-10-27"
  },
  {
    "id": 9,
    "title": "🤖 Discord Bot 筆記",
    "content": "# 🤖 Discord Bot 筆記\n> [sisct 講義](https://drive.google.com/file/d/1Np7TRo6ZozY4-fdERnqxucEQngxCGfae/view?usp=sharing)\n\n---\n\n## 📌 什麼是 Discord？\n\n- **功能**：\n  - 建立主題伺服器\n  - 成員權限控制\n  - 語音、訊息互動\n- **優勢**：\n  - 好用的聊天平台\n  - 遠勝 LINE 的社群體驗\n\n---\n\n## ⚙️ 什麼是 Discord Bot？\n\n- 類似虛擬用戶，透過 **websocket + API** 與 Discord 溝通。\n- Discord Bot = 把程式透過 Discord UI 輸入/輸出\n- 自動化功能包括：\n  - 訊息回應\n  - 身分組設定\n  - 頻道建立\n  - 使用者互動等\n\n---\n\n## 🔗 什麼是 API？\n\n- 應用程式介面，讓程式間能互相溝通。\n- 在 Discord Bot 開發中使用 API（如 py-cord）來整合指令與回應。\n\n---\n\n## 🛠 如何開始製作 Bot？\n\n### 📦 需要準備：\n- Python 語言\n- py-cord 套件\n\n### ✅ 安裝步驟：\n\n#### 確認 Python 已安裝\n```\npython3 --version\n```\n\n#### 確認 pip 可用\n\n```\npip3 --version\n```\n\n#### 安裝 py-cord\n```\npip3 install py-cord\n```\n\n#### 檢查安裝成功\n```\npip3 list | grep \"py-cord\"   # Mac/Linux\npip3 list | find \"py-cord\"   # Windows\n```\n\n\n### 🧑‍💻 建立 main.py 基本結構\n#### 引入模組與初始化：\n```py\nimport discord\nfrom discord.ext import commands\n\nintents = discord.Intents.all()\nbot = commands.Bot(command_prefix=\"/\", intents=intents)\n```\n#### 啟動 bot：\n```py\n@bot.event\nasync def on_ready():\n    print(f'Logged in as {bot.user}!')\n\nbot.run(\"your_bot_token\")\n```\n### 📬 事件處理 @event\n#### 成員加入通知：\n\n```py\n@bot.event\nasync def on_member_join(member):\n    channel = bot.get_channel(YOUR_CHANNEL_ID)\n    await channel.send(f\"{member.mention} 歡迎加入！\")\n```\n#### 訊息監聽回覆：\n```py\n@bot.event\nasync def on_message(message):\n    if message.author == bot.user:\n        return\n    if message.content == \"ping\":\n        await message.channel.send(\"pong\")\n```\n### 🔀 斜線指令 @slash_command\n```py\n@bot.slash_command(name=\"hello\", description=\"Say hello!\")\nasync def hello(ctx):\n    await ctx.respond(\"Hello 👋\", ephemeral=True)\nctx.respond()：回應訊息（可設 ephemeral）\n```\n\n> 指令提示由 Discord 內建支援，UX 更佳\n\n### 🧾 使用 JSON 儲存資料\n#### 檔案格式：\n```json\n{\n  \"hello\": \"world\",\n  \"red_fruit\": [\"apple\", \"cherry\"],\n  \"flower\": \"rose\"\n}\n```\n#### Python 操作 JSON：\n```py\nimport json\n\nwith open(\"data.json\", \"r\") as f:\n    data = json.load(f)\n\nprint(data[\"hello\"])  # world\n```\n---\n## ❓ 常見問題\n* 指令未出現：重啟 Discord（Ctrl/Cmd + R）\n\n* Token 洩漏：立即 reset，避免被盜控！\n---\n## 💻 範例程式\n```py\nimport discord\nimport json\n\nwith open('data.json', 'r') as file:\n    data = json.load(file)\n\nbot = discord.Bot(intents = discord.Intents.all())\n\n# 上線提醒\n@bot.event\nasync def on_ready():   #異步函數\n    print(f\"{bot.user} 不想上班💩\")\n\n# 對話\n@bot.event\nasync def on_message(message):\n    # 避免 loop\n    if message.author == bot.user:\n        return\n    # 如果使用者船ping，機器人船pong\n    elif message.content == \"ping\":\n        await message.channel.send(\"pong\")\n    elif \"rickroll\" in message.content:\n        await message.channel.send(\"https://youtu.be/p7YXXieghto\")\n\n# 使用者加入\n@bot.event\nasync def on_member_join(member):\n    welcome_channel_id = 1370659139000340551\n    welcome_channel = bot.get_channel(welcome_channel_id)\n    await welcome_channel.send(f\"{member.mention}醬~ 嗨~ 你喜歡什麼?\")\n\n# 斜線指令\n@bot.slash_command(description=\"ping pong pong\")\nasync def ping(ctx):\n    await ctx.respond(\"pong\", ephemeral=True)\n\nbot.run(data[\"token\"])\n\n```",
    "tags": "專題 ",
    "date": "2025-05-22"
  },
  {
    "id": 10,
    "title": "RL期末專題_貪吃蛇",
    "content": "# RL 期末專題\n>[github 連結](https://github.com/sarah21392773/AI/tree/main/Snake_RL)\n---\n\n## 壹、問題敘述\n\n### ● 選用環境\n\n使用 Pygame 自製的「貪吃蛇」遊戲，改造成類似 gymnasium 格式的強化學習環境，新增了 `reset()`、`play_step(action)`、`is_collision()` 等函式。\n\n### ● 遊戲目標\n\n操控貪吃蛇在不碰撞的情況下吃紅點以獲高分。\n\n### ● 狀態空間\n\n11 維布林值向量（使用 one-hot encoding）代表：\n\n* 危險判斷：`danger_straight`, `danger_right`, `danger_left`\n* 當前方向：`move_left`, `move_right`, `move_up`, `move_down`\n* 食物方向：`food_left`, `food_right`, `food_up`, `food_down`\n\n例如：\\[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1]\n\n### ● 動作空間\n\n使用 one-hot encoding 表示三種離散動作：\n\n* \\[1, 0, 0]：直行（什麼都不做）\n* \\[0, 1, 0]：向右轉（順時針）\n* \\[0, 0, 1]：向左轉（逆時針）\n\n### ● 獎勵機制\n\n| 情況    | 獎勵值 | 說明      |\n| ----- | --- | ------- |\n| 吃到食物  | +10 | 鼓勵      |\n| 撞牆或自撞 | -10 | 處罰      |\n| 其他    | 0   | 正常移動不加分 |\n\n### ● 死亡條件\n\n* 撞牆\n* 撞自己\n* 時間 > 100 x 蛇長\n\n---\n\n## 貳、DQN原理介紹\n\n### ● 探索與利用\n\n使用 \\$ε\\$-greedy 策略平衡探索與利用。\n\n### ● DQN\n\n深度 Q 網路（Deep Q Network）使用神經網路近似 Q 函數，取代傳統 Q-Table。\n\n### ● Replay Buffer\n\n儲存 `(state, action, reward, next_state)` 經驗以提升訓練效率，打亂相關性避免過擬合。\n\n### ● Fixed Q Target\n\n使用兩套網路（current, target）穩定 Q 值學習。\n\n### ● Bootstrapping\n\n用估計去更新同類估計，結合當下與未來的資訊改進策略。\n\n### ● Double DQN\n\n分離動作選擇與評估，降低 Q 值過高估計問題。\n\n### ● Dueling DQN\n\n將 Q 值分為：\n\n* 狀態價值 V(s)\n* 優勢值 A(s,a)\n  使用 \\$Q(s, a) = V(s) + (A(s,a) - \\frac{1}{|A|} \\sum A(s,a'))\\$\n\n### ● Prioritized Experience Replay (PER)\n\n根據 TD 誤差進行經驗抽樣，強化學習效率。\n\n### ● Rainbow-lite DQN\n\n結合 Double DQN、Dueling DQN 和 PER。\n\n---\n\n## 參、研究方法\n\n### 1. 各 DQN 架構\n\n#### ● DQN\n\n* 全連接層：11 → 128 → 64 → 3（對應 3 個動作）\n* 使用 Replay Buffer 與 Fixed Q Target\n\n#### ● Double DQN\n\n* 架構同 DQN\n* 使用 model 選擇動作，target\\_model 計算 Q 值\n\n#### ● Dueling DQN\n\n* 架構分為：Value 分支（輸出 V）、Advantage 分支（輸出 A）\n* 合併公式如前所述\n\n#### ● PER DQN\n\n* 架構同 DQN\n* 使用 TD error 作為抽樣依據，加上 IS 修正權重\n\n#### ● Rainbow-lite DQN\n\n* 架構綜合上述三者\n\n### 2. 模型訓練比較\n\n* 所有模型共通參數：\n\n  * \\$γ=0.9\\$\n  * lr=0.001\n  * eps\\_low=0.05\n  * N\\_EPISODES=1000\n\n---\n\n## 肆、研究結果與分析\n\n| 演算法          | 最高分   | 最終收斂  | 特性描述             |\n| ------------ | ----- | ----- | ---------------- |\n| DQN          | \\~150 | \\~125 | 緩慢穩定             |\n| Double DQN   | \\~150 | \\~125 | 初期佳，後期不穩         |\n| Dueling DQN  | \\~135 | \\~125 | 變異大，效果最差         |\n| PER DQN      | \\~160 | \\~140 | 穩定最佳模型           |\n| Rainbow-lite | \\~150 | \\~125 | 初期成長快，後期與 DQN 相近 |\n\n* 所有模型在 600 回合後表現下降，疑似過擬合。\n\n---\n\n## 伍、討論與心得\n\n1. 更具體理解 DQN 相關理論與實作。\n2. 環境設計需避免讓 agent 原地打轉，但過於限制可能造成後期困難。\n3. 仿 gymnasium 設計仍待補全（如 render 函式）。\n4. Rainbow-lite 效果不如預期，未來可試完整 Rainbow DQN 或調參。\n\n---\n\n## 陸、參考資料\n\n* StackOverflow: Mini-Batches in RL. [https://stackoverflow.com/questions/53864434/mini-batches-in-rl](https://stackoverflow.com/questions/53864434/mini-batches-in-rl)\n* Medium: N-Step Bootstrapping in RL. [https://medium.com/@amit25173/n-step-bootstrapping-in-reinforcement-learning-e4f70f264933](https://medium.com/@amit25173/n-step-bootstrapping-in-reinforcement-learning-e4f70f264933)\n* 博客園: Prioritized Replay DQN. [https://www.cnblogs.com/pinard/p/9797695.html](https://www.cnblogs.com/pinard/p/9797695.html)\n* 博客園: DQN 系列介紹. [https://www.cnblogs.com/jiangxinyang/p/10112381.html](https://www.cnblogs.com/jiangxinyang/p/10112381.html)\n* 掘金: Rainbow DQN. [https://juejin.cn/post/7327723045287559205](https://juejin.cn/post/7327723045287559205)\n* CSDN: 自定義強化學習環境. [https://blog.csdn.net/weixin\\_41434829/article/details/139204435](https://blog.csdn.net/weixin_41434829/article/details/139204435)\n* 成果影片: [https://drive.google.com/file/d/14i73H42KfBccfzgJtc4\\_VZZU\\_HrZJ6r3/view?usp=sharing](https://drive.google.com/file/d/14i73H42KfBccfzgJtc4_VZZU_HrZJ6r3/view?usp=sharing)",
    "tags": "專題 ,AI ",
    "date": "2025-07-01"
  },
  {
    "id": 11,
    "title": "TOI 潛力組 k715. 糧食便道 (Supply)",
    "content": "# TOI 潛力組 k715. 糧食便道 (Supply)\n\n*  題目連結：<br/>\n&emsp;[在這裏～～](https://zerojudge.tw/ShowProblem?problemid=k715)\n \n---\n\n## **理解題意**\n\n---\n\n### 目標\n有 `N` 個城鎮，其中 `K` 個城鎮有糧食。建立道路(共有 `M` 條路可供選擇)，**讓每個城鎮至少連接到一個有糧食的城鎮**，而且總成本最小。\n\n* 範例:\n![螢幕擷取畫面 2025-08-03 005308](https://hackmd.io/_uploads/HJnKG6jvge.png)\n\n\n    * 輸入: 有 N = 8 個城鎮，編號 1 至 8。城鎮 3 以及城鎮 8 有生產糧食 (星星)。\n    * 輸出: 10 (如圖二)\n    \n---    \n    \n## 解題\n\n---\n### 解題思路\n1. 用 `struct` 結構紀錄道路的兩端與成本，提高可讀性與操作方便。\n2. 為了避免額外標記「誰有糧食」的麻煩，**引入虛擬原點（編號 0）**，且其與「有糧食的城市」邊權為 0。\n3. 對所有邊（包含虛擬邊）進行 `Kruskal 最小生成樹演算法`，總成本即為所求。\n\n:::danger \n! ! ! 解題關鍵:<br/>單純用 **Kurkal + 森林** 只能確保所有城市用最小成本相連，但**不能確保每棵樹都有糧食原點**。所以應該加入`虛擬原點`。\n:::\n![88237f00-ff3c-4343-b4d6-ad28d6d857df](https://hackmd.io/_uploads/rJ8ozrnDle.jpg)\n\n\n### 程式碼\n\n```c++=\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\n\n\nstruct Road{\n    int left, right, weight;\n    bool operator<(const Road& r) const{\n        return weight < r.weight;\n    }\n};\n\nint N, M, K, ans;\nvector<int> root, sz;\npriority_queue<int> pq;\n\nint Find(int a){\n    if(root[a] == a) return a;\n    return root[a] = Find(root[a]);\n}\n\nbool Union(int a, int b){\n    a = Find(a), b = Find(b);\n    if(a == b) return false;\n    if(sz[a] > sz[b]) swap(a, b);\n    sz[b] += sz[a];\n    root[a] = Find(b);\n    return true;\n}\n\nint main(){\nios::sync_with_stdio(false);cin.tie(0);\n    // initial\n    cin >> N >> M >> K;\n    vector<Road> roads;\n    sz.assign(N+1, 1);\n    root.assign(N+1, 0);\n    iota(all(root), 0);\n    // invisible plot 0 (weight = 0)\n    int temp;\n    for(int i=0; i<K; i++){\n        cin >> temp;\n        roads.push_back({0, temp, 0});\n    }\n    // input the roads\n    int a, b, c;\n    for(int i=0; i<M; i++){\n        cin >> a >> b >> c;\n        roads.push_back({a, b, c});\n    }\n    // Kruskal\n    sort(all(roads));\n    for(auto & r:roads){\n        if(Union(r.left, r.right))\n            ans += r.weight;\n    }\n    cout << ans << \"\\n\";\nreturn 0;\n}\n```\n\n### 補充\n\n* iota() 用法\n    * 目的:<br/>將陣列填入遞增元素\n    * 語法:<br/>`iota(arr.begin(), arr.end(), 開始元素)`\n    \n    * 範例:\n        arr[6] = {}\n        輸入: `iota(arr.begin(), arr.end(), 0)`\n        輸出: 0 1 2 3 4 5<br/>\n\n* 最小生成樹\n    [觀念](https://hackmd.io/@konchin/MST)\n\n\n---\n## 廢話區\n---\nya!",
    "tags": "競程 ,TOI ",
    "date": "2025-07-13"
  },
  {
    "id": 12,
    "title": "第65屆高雄市科展 -- RL_CarRacing",
    "content": "# 🏎️ RL_CarRacing\n\n## 科展專題：應用強化學習與生成網路於自動駕駛訓練\n> 作者: 吳苡柔、黃品薰、郭依瑾　　指導老師: 邱崑山、段雅培\n\n> [github 連結](https://github.com/sarah21392773/AI/tree/main/CarRacing_RL)\n\n### 📌 專題簡介\n\n本研究以 **OpenAI Gym CarRacing** 環境為平台，探討如何利用 **深度強化學習 (Deep Reinforcement Learning)** 及 **生成式模型 (AE/VAE)** 來訓練自動駕駛代理人。\n透過不同演算法、感知方式及獎勵機制的比較，分析其對模型表現與學習效率的影響，期望能找到更穩定且高效的自動駕駛訓練方式。\n\n---\n\n### 🎯 研究動機\n\n* 2025 CES 展示了自動駕駛的未來潛力，啟發我們探索其實現方式。\n* 強化學習可透過「嘗試錯誤」讓智能體學會駕駛決策。\n* 我們希望結合 **DQN 改進演算法** 與 **生成式 AI (AE/VAE)**，提升自動駕駛智能體的穩定性與表現。\n\n---\n\n### ⚙️ 研究方法\n\n1. **演算法實驗**\n\n   * DQN\n   * Double DQN\n   * Dueling DQN\n\n2. **探索策略**\n\n   * ε-greedy 演算法\n   * 不同 ε 衰減策略比較\n\n3. **環境改寫**\n\n   * 裁切影像：96×96 → 84×84 → 72×72\n   * 修改獎勵機制：鼓勵車輛保持賽道中央\n   * Replay Buffer 改進：由均勻採樣 → 步數加權採樣\n   * 增加「出界即終止」條件，模擬真實駕駛環境\n\n4. **感知 AI 實驗**\n\n   * 使用不同觀測空間：空照圖、車前影像、感知融合\n   * 加入生成式 AI：\n\n     * AE (AutoEncoder)\n     * VAE (Variational AutoEncoder)\n\n---\n\n### 🖥️ 實驗設備\n\n* **硬體**：Nvidia Jetson Orin 16GB\n* **軟體**：Python 3.10、PyTorch、Google Colab\n\n---\n\n### 📊 研究結果\n\n1. **演算法比較**\n\n   * Dueling DQN > DQN > Double DQN\n   * Dueling DQN 收斂較快，表現最穩定。\n\n2. **探索策略**\n\n   * 衰減係數 x=5 表現最佳。\n   * 適度探索 + 收斂能平衡學習速度與最終表現。\n\n3. **獎勵機制**\n\n   * 修改後能加快前期學習速度，提升探索效率。\n\n4. **感知方式**\n\n   * 車前影像比空照圖更接近真實，初期學習更快，但後期表現略不穩定。\n   * 感知融合未優於單一輸入，可能因環境過於簡單。\n\n5. **生成式 AI 輔助**\n\n   * VAE 效果優於 AE，泛化能力較強。\n   * AE/VAE 在探索期能加快學習，但貪婪階段表現略差。\n\n6. **Replay Buffer 改進**\n\n   * 「步數加權採樣」能改善出界即終止所造成的早期重複學習問題。\n\n---\n\n### 📌 結論\n\n* **最佳演算法**：Dueling DQN\n* **最佳探索策略**：ε 衰減係數 = 5\n* **最佳獎勵設計**：以賽道中央為基準修正獎勵\n* **生成式 AI**：VAE 較有潛力提升泛化性\n* **改進方向**：\n\n  * 增加真實模擬環境複雜度\n  * 探索連續動作空間的演算法（如 DDPG, SAC）\n  * 加入緩衝區設計，提升安全性與補救能力\n\n---\n\n### 📎 參考文獻\n\n* Mnih et al. (2015). *Human-level control through deep reinforcement learning*. Nature.\n* Wang et al. (2016). *Dueling Network Architectures for Deep Reinforcement Learning*. arXiv.\n* Sutton & Barto. *Reinforcement Learning: An Introduction*.\n* 其他參考來源包含 Medium、IBM、Udacity 等。\n\n---\n> 獲得高雄市第65屆科展_資訊組，團體合作獎",
    "tags": "專題 ,AI ",
    "date": "2025-04-26"
  },
  {
    "id": 13,
    "title": "高一資訊課_解題反思",
    "content": "# 解題反思\n\n本文件整理了「高一資訊課」解題過程中的程式錯誤、修正與心得，包含 4 道題目。\n\n---\n\n## 題目 1：數字結合 (Combination)\n\n### 題目敘述\n將兩個數字合併後，判斷是否為 11 的倍數。  \n規則：若奇數位數字和與偶數位數字和的差為 0 或 11 的倍數，則為 11 的倍數。\n\n- **輸入**：兩個整數 X, Y（長度 ≤ 50 位）  \n- **輸出**：Yes / No  \n\n**範例**\n```\n\n輸入: 1 1       → 輸出: Yes\n輸入: 1345 7092 → 輸出: Yes\n輸入: 12 213    → 輸出: No\n\n````\n\n### 錯誤程式碼\n```cpp\nchar t = c[i];\nsuma += int(t);   // 取得 ASCII 值\n````\n\n### 修正後程式碼\n\n```cpp\nchar t = c[i];\nsuma += t - '0';  // 修正：轉換為數字\n```\n\n### 策略與反思\n\n* 利用 `'0'` ~ `'9'` 在 ASCII 中連續排列的特性，做減法取得數值。\n* 一開始以 `long long int` 嘗試，結果資料過大失敗，改用字串後仍錯誤。\n* 學到字元運算後，才發現錯誤來源，最終修正成功。\n\n---\n\n## 題目 2：精靈王國 (Kingdom)\n\n### 題目敘述\n\n每個傳送點會傳送到另一個傳送點，需計算擁有最多傳送點的王國大小。\n\n* **輸入**：K（傳送點總數）、K 個 ai 值（第 i 個傳送點的目的地）\n* **輸出**：最大王國的傳送點數量\n\n**範例**\n\n```\n輸入:\n7\n1 3 4 5 6 7 2\n輸出: 6\n```\n\n### 錯誤程式碼\n\n```cpp\nwhile(t != h){   // 當傳送點未回到起點\n    s++;\n    t = a[t-1];\n}\n```\n\n### 修正後程式碼\n\n```cpp\na[i] = 0;   // 標記已傳送過的點\nwhile(t != home && t != 0){\n    sum++;\n    int t2 = t;\n    t = a[t-1];\n    a[t2-1] = 0; // 避免重複計算\n}\n```\n\n### 策略與反思\n\n* 原始程式在小測資能通過，但大測資出現 TLE。\n* 改以「標記已傳送過的點」方式，避免重複計算，提高效率。\n* 學到設計演算法時需考慮時間複雜度。\n\n---\n\n## 題目 3：禮品採購\n\n### 題目敘述\n\n小黃可在第四季以前三季平均價購買禮品。\n若前三季最高價與最低價差 ≥ d，則購買。輸出總購買數量與總金額。\n\n**範例**\n\n```\n輸入:\n3 5\n28 32 27\n20 15 25\n77 77 77\n輸出:\n2 49\n```\n\n### 錯誤程式碼\n\n```cpp\nint M=0, m=100, b=0;\nfor(int j=0; j<3; j++){\n    cin >> a[i][j];\n    b += a[i][j];\n    if(a[i][j] > M) M = a[i][j];\n    else if(a[i][j] < m) m = a[i][j];\n}\n```\n\n### 修正後程式碼\n\n```cpp\nint a[3], b=0, M=0, m=100;\nfor(int j=0; j<3; j++){\n    cin >> a[j];\n    b += a[j];\n    M = max(M, a[j]);\n    m = min(m, a[j]);\n}\n```\n\n### 策略與反思\n\n* 原本使用二維陣列與 if 判斷，程式冗長且容易出錯。\n* 改成一維陣列，並使用 `max()` 與 `min()`，程式更精簡直觀。\n* 體會到簡化程式碼的重要性，避免錯誤並提升可讀性。\n\n---\n\n## 題目 4：傳輸費用\n\n### 題目敘述\n\n給定伺服器數量 n、城市數量 m、方案數量 k，每個方案將伺服器分配到城市，計算所有方案中的最低傳輸費用。\n\n* **費用規則**：\n\n  * 同城市：每單位 1 元\n  * 不同城市：≤1000 單位 → 每單位 3 元；超過部分 → 每單位 2 元\n\n**範例**\n\n```\n輸入:\n2 3 2\n900 500 300\n300 600 1200\n2 0\n2 2\n\n輸出:\n8100\n```\n\n### 錯誤程式碼\n\n```cpp\nfor (int city = 0; city < m; city++) {\n    same[city] = 0;\n    for (int s = 0; s < n; s++) {\n        if (city == cities[s]) {\n            totalCost += Q[s][city];\n        } else {\n            same[city] += Q[s][city];\n        }\n    }\n}\n```\n\n### 修正後程式碼\n\n```cpp\nfor (int j = 0; j < n; j++) {\n    int cases = 0;\n    cin >> cases;\n    for(int p=0; p<m; p++){\n        trans[cases][p] += Q[j][p];\n    }\n}\n\n// 再依規則計算費用\nif(i == j) totalcost += trans[i][j];\nelse if(trans[i][j] > 1000)\n    totalcost += 3000 + (trans[i][j] - 1000) * 2;\nelse\n    totalcost += trans[i][j] * 3;\n```\n\n### 策略與反思\n\n* 原始程式沒有正確合併同城市伺服器的流量，導致錯誤。\n* 改用 `trans[m][m]` 矩陣記錄各城市間傳輸總量，再依規則計算。\n* 學到設計資料結構能有效解決計算錯誤問題。\n\n---\n\n## 整體反思\n\n* 僅有基礎語法已不足以應付進階題目，需要學習更多標準函式與技巧。\n* 建立正確的基礎觀念與邏輯思維，對解題至關重要。\n* 遇到問題時，應嘗試不同角度去思考，增加解題靈活性。\n* 程式設計是一個 **不斷反思、不斷成長的過程**。",
    "tags": "競程 ",
    "date": "2024-01-26"
  },
  {
    "id": 14,
    "title": "AI詩人",
    "content": "# 詩句賞析\n\n> [github 連結](https://github.com/sarah21392773/AI/tree/main/AI%E8%A9%A9%E4%BA%BA)\n---\n\n 跨領域專題: 資訊+國文\n\n## 第一區\n- **「惡犬」**：點出戰爭的兇殘，以短短兩字呈現戰爭的猛烈與快速；其中「犬」暗示敵人為大漠民族。  \n- **「15年」**：突顯戰爭的漫長。  \n- **「誰又起戰鼓聲」**：表達對戰爭的麻木。  \n- **「願蒼天圓我楊家父子將」**：希望能與當兵的父親相聚。  \n- **「若拼傲奸佞敢把寸土讓」**：盼望戰爭早日結束，敵人投降，不讓寸土。  \n- **「先問我楊家夢，受太宗重用進宋門，我江山方寸地」**：因受到太宗重用，期望能將這份人情回報給大宋，保家衛國。  \n\n## 第二區\n- **「現捨身報國血染盔，視保家衛國為護國心」**：描繪戰場上捨身衛國、遍體鱗傷，並再次強調對大宋的忠誠。  \n- **「是一朝天子兩朝臣，以赤膽忠心保大宋」**：呼應第一段的「15年」，即使改朝換代仍然忠心耿耿。  \n- **「老令公自有心不甘」**：雖然年老，仍未能平亂，心有不甘。  \n- **「金沙灘」**：點出戰場位於中國西方的大漠。  \n\n## 第三區\n- **兵敗歸鄉**：只能與父親再度橫越大漠，返回家鄉。  \n- **「吾世代皆為平寇兵敗兩朝臣」**：表達楊家世代皆為大宋付出青春，卻仍難免戰敗的無奈。  \n\n## 第四區\n- **「這苦難老身亦可寒女嬋」**、**「這自古難有巾幗將」**：強調自古少有女將軍，卻能在楊家出現，顯示楊家對大宋的忠誠與犧牲。",
    "tags": "專題 ,AI ",
    "date": "2024-06-19"
  },
  {
    "id": 15,
    "title": "RL期末專題(小組)",
    "content": "# 113學年度上學期 強化學習 DQN 期末專題\n> [github 連結](https://github.com/sarah21392773/AI/tree/main/RL%E6%9C%9F%E6%9C%AB%E5%B0%88%E9%A1%8C(%E5%B0%8F%E7%B5%84))\n---\n\n## 壹、問題敘述\n- **環境**：`gymnasium CarRacing-v3`\n- **遊戲目標**：駕駛汽車在灰色賽道格子上行駛並避免偏離賽道\n- **狀態空間**：RGB 影像，大小 (96, 96, 3)\n- **動作空間**  \n  - **連續動作**：方向盤(-1~+1)、油門、煞車  \n  - **離散動作**：不動、左轉、右轉、加速、煞車\n- **獎勵機制**：  \n  - 每幀：-0.1  \n  - 踩到賽道格子：+1000/N  \n  - 偏離賽道：-100（遊戲結束）\n- **環境參數**：\n  - `lap_complete_percent=y`：需通過 y% 格子才算完成一圈\n  - `domain_randomize`：背景與賽道顏色是否隨機\n  - `continuous=False`：切換至離散動作空間\n\n---\n\n## 貳、DQN 原理介紹\n- **探索與利用 (Exploration vs Exploitation)**：透過 ε-greedy 在探索與利用間取得平衡\n- **DQN (Deep Q-Network)**：以深度神經網路近似 Q 函數，解決 Q-Table 無法處理高維狀態的問題\n- **Replay Buffer**：存儲過往經驗，隨機抽樣以避免樣本相關性\n- **Fixed Q Target**：分為當前 Q 網路與目標 Q 網路，提升學習穩定性\n- **Bootstrapping**：使用現有估計值結合未來回報來更新策略\n- **Double DQN**：使用兩個網路避免 Q 值高估\n- **Dueling DQN**：分解 Q 值為「狀態價值」與「優勢函數」，提升效率\n- **Nature DQN**：採用 CNN 結構，並使用兩個獨立 Q 網路（PredictQ、TargetQ）\n\n---\n\n## 參、研究方法\n- **演算法實作**  \n  - DQN：以 CNN 作為 Q 網路（兩層卷積＋兩層全連接），並加入 Replay Buffer 與 Fixed Q Target  \n  - Double DQN：將動作選擇與價值評估拆分為 Predict Q、Target Q  \n  - Dueling DQN：將 Q 網路分為狀態價值函數 V(s) 與優勢函數 A(s,a)  \n  - Nature DQN：使用三層卷積與兩層全連接，損失函數改為 MSELoss\n- **參數設定**  \n  - 折扣因子 γ = 0.95  \n  - 探索率下限 ε_low = 0.05  \n  - 學習率 lr = 0.00025  \n  - 訓練回合數 N_EPISODES = 1000\n\n---\n\n## 肆、研究結果與分析\n1. **探索率衰減實驗**  \n   - 探索率下降越快，初期收斂越快，但後期震盪也較大\n   - x=12 的收斂速度最快，但 4000 回合後差異趨緩\n2. **不同演算法訓練比較**  \n   - 效果排序：**Dueling DQN > DQN > Nature DQN > Double DQN**\n   - DQN 在 1000 回合後出現 Overfitting\n   - Double DQN 表現不佳，可能是訓練不足或不適合此環境\n3. **不同演算法測試比較**  \n   - 平均獎勵最佳：Dueling DQN  \n   - 獎勵穩定性最佳：Double DQN（標準差最低）  \n   - Nature DQN 表現中等，但震盪持續  \n   - 總結：Dueling DQN 整體效果最佳，但波動較大\n\n---\n\n## 伍、討論與心得\n- 更深入理解了 **DQN 及其改良演算法** 的運作機制\n- 實驗中看見 **探索率衰減對訓練收斂的影響**\n- 比較不同 DQN 演算法在 CarRacing 環境中的表現，了解其優缺點\n- 目前僅嘗試基礎版本，未來可延伸至：\n  - Prioritized Replay DQN\n  - Rainbow DQN\n  - 其他強化學習改進演算法\n\n---\n\n## 柒、參考資料\n- Car Racing 環境：  \n  [Gymnasium Car Racing](https://gymnasium.farama.org/environments/box2d/car_racing/)  \n- Replay Buffer：  \n  [Mini-Batches in RL - StackOverflow](https://stackoverflow.com/questions/53864434/mini-batches-in-rl)  \n- Bootstrapping：  \n  [N-Step Bootstrapping in RL - Medium](https://medium.com/@amit25173/n-step-bootstrapping-in-reinforcement-learning-e4f70f264933)  \n- Nature DQN 論文：  \n  [DeepMind DQN Paper](https://storage.googleapis.com/deepmind-media/dqn/DQNNaturePaper.pdf)  \n- DQN 系列：  \n  [博客文章 - DQN 系列介紹](https://www.cnblogs.com/jiangxinyang/p/10112381.html)  \n\n---\n📊 **結論**：  \n在 CarRacing-v3 環境中，**Dueling DQN** 整體表現最佳，但仍需調整以減少後期震盪；**Double DQN** 表現最差；探索率衰減對訓練前期影響較大，但後期差異不明顯。\n---\n## 分工表\n\n| 座號 | 姓名   | 負責工作                                                                 |\n|------|--------|--------------------------------------------------------------------------|\n| 05   | 吳苡柔 | 訓練 Nature DQN 模型、研究結果與分析、繪製圖表、研究方法、討論與心得      |\n| 17   | 郭倢妤 | 撰寫問題敘述、DQN 原理介紹                                               |\n| 21   | 黃品薰 | 訓練 DQN、Double DQN、Dueling DQN 模型、研究結果與分析、研究方法、討論與心得 |",
    "tags": "專題 ,AI ",
    "date": "2025-02-12"
  },
  {
    "id": 16,
    "title": "監督式學習_電子元件的影像辨識",
    "content": "# 🔌常用接口辨識專題報告\n\n> [報告影片連結](https://youtu.be/PG1SgHBdjVo)\n\n> [github 連結](https://github.com/sarah21392773/AI/tree/main/%E7%9B%A3%E7%9D%A3%E5%BC%8F%E5%AD%B8%E7%BF%92_%E9%9B%BB%E5%AD%90%E5%85%83%E4%BB%B6%E7%9A%84%E5%BD%B1%E5%83%8F%E8%BE%A8%E8%AD%98)\n## 專題簡介\n在現今的數位生活中，我們常常會遇到各種不同的線材和接口，但卻不知道它們的名字。  \n本專題透過 **影像辨識 (Image Classification)** 技術，訓練出一個 AI 模型來幫助我們分辨這些常見的物理界面。  \n\n我們希望能協助使用者在面對眾多接口時，能夠快速辨識並選擇合適的線材，從而提升生活效率。\n\n## 研究對象\n本專題選擇了七種比較常見的接口進行研究：\n- **VGA**：傳輸模擬視訊信號，多用於舊式顯示器與投影機  \n- **HDMI**：現代電視、電腦螢幕的主流接口，用於高畫質影音傳輸  \n- **Mini USB**：常用於翻譯機、行車紀錄器等小型裝置  \n- **Micro USB**：過去廣泛應用於安卓手機  \n- **USB Type-A**：常見於電腦等裝置  \n- **USB Type-C**：高速傳輸、雙面插入，現代行動裝置的主流接口  \n- **Lightning**：蘋果設備專用接口  \n\n## 方法與流程\n1. **資料集準備**  \n   - 訓練集：367 筆  \n   - 測試集：105 筆  \n   - 資料增強：  \n     - 訓練集：隨機裁剪、隨機旋轉  \n     - 測試集：中央裁剪  \n   - 最後進行歸一化  \n\n2. **索引與分類對應**  \n   - 建立字典（索引 ↔ 分類）  \n   - 存成 `.npy` 檔  \n\n3. **模型選擇與訓練**  \n   - 自建 CNN（兩層卷積+池化、三層全連接層），準確率僅 **42%**  \n   - 遷移式學習 (Transfer Learning)：  \n     - ResNet-18：**55%**  \n     - AlexNet：**63%**  \n     - GoogleNet：**70%**  \n   - 最終採用 **GoogleNet**，並微調所有層參數  \n   - 訓練 500 回合，達到最終準確率 **84.8%**  \n   - 超過 750 回合出現 **Overfitting**  \n\n4. **資料清理**  \n   - 移除兩端不同接口的轉接器照片  \n   - 對多接口圖片進行裁切  \n   - 修正錯誤分類樣本  \n\n## 結果\n- 最終準確率：約 **84.76%**  \n- QR Code（資料集）：包含七種常見線材的分類照片  \n\n## 遇到的問題與解決方式\n- **準確率過低** → 改用遷移式學習，逐步測試不同模型  \n- **模型 Overfitting** → 控制訓練回合數  \n- **資料集品質不佳** → 進行清理與分類修正  \n\n## 心得與反思\n- 過程中我們更深入地了解了各種線材接口，避免實務中插錯接頭的困擾。  \n- 熟悉了遷移式學習的應用，並學會比較不同模型與回合數對結果的影響。  \n- 主題發想過程中，曾考慮過國旗、食物、影子辨識，但因需考慮顏色、形狀變化等因素，最終選擇了線材辨識作為專題。  \n\n## 未來展望\n1. 嘗試 **VGG16** 模型，觀察是否能進一步提升準確率  \n2. 結合 **生成式 AI**，提供接口相關資訊（例如：使用注意事項、廠牌等）  \n3. 從單純的 **影像分類 (Image Classification)** 擴展到 **物件辨識 (Object Detection)**，解決轉接線無法正確分類的問題  \n\n---\n📌 **本專題繼上次的「剪刀 / 石頭 / 布 / 鑽頭」影像辨識後，再次實作影像辨識應用，並最終獨立為一個新專題。**",
    "tags": "專題 ,AI ",
    "date": "2024-06-28"
  },
  {
    "id": 17,
    "title": "IBM企業參訪",
    "content": "# IBM企業參訪\n\n## 一、活動緣起\n本校資訊組長邱崑山老師於2024年3月8日的資安女婕思活動中遇到IBM管理階層，並為一年級電資班爭取到IBM企業參訪的機會。於2024年5月27日，我們利用校定必修議題探究課程前往參訪。\n\n在崑山老師告知我們參訪訊息前，我對IBM並不熟悉。參訪前我先在網路上查詢了相關資料，發現IBM在科技業中舉足輕重，尤其在硬體方面表現優異，例如許多大型企業的伺服器和影像設備均來自IBM。\n\n---\n\n## 二、活動過程\n### 1. 參訪前準備\nIBM要求我們完成**IBM SkillsBuild**線上平台的「探索新興技術」課程，內容涵蓋：  \n- 雲端運算  \n- AI  \n- 網路安全  \n- 資料科學  \n- 區塊鏈  \n- IoT  \n\n我花了約六小時完成所有課程，雖然內容稍微表面化，但對參訪前的基本認知有幫助。\n\n### 2. 參訪當天體驗\n當天到達IBM公司外觀時，我對建築的外觀與科技感落差頗大，尤其外部的水管裝置藝術與我想像的科技感完全不同。然而，進入建築內部後，乾淨明亮的大廳、透明電梯、舒適的休息室讓我非常驚艷。我心想：「要是未來能在這種環境工作該多好呀！」  \n\n我們隨後被帶到會議室，活動流程如下：  \n1. IBM介紹  \n2. Q&A  \n3. IBM SkillsBuild大挑戰  \n4. 雄女學姊分享  \n5. STEAM女力工坊  \n\n### 3. 活動亮點\n- **IBM介紹**：介紹公司歷史、科技業地位及產品。  \n- **Q&A**：解答我們對工程師日常、入職條件等疑問，顛覆先前想像。  \n- **SkillsBuild大挑戰**：考驗線上學習成果，我們小組獲得第一名。  \n- **雄女學姊分享**：分享生涯歷程，鼓勵勇於探索與嘗試。  \n- **STEAM女力工坊**：用20張色紙、3雙竹筷、膠帶和1個紙杯搭建承重摩天大樓（>15公分，高度可承受5個鐵塊）。\n\n### 4. 活動圖片\n1. ![IBM SkillsBuild課程證明](./images/skillsbuild.png)  \n2. ![高雄IBM外觀](./images/ibm_building.png)  \n3. ![參訪行程表](./images/schedule.png)  \n4. ![參訪前後想法差異](./images/thought_change.png)  \n5. ![SkillsBuild大挑戰頒獎](./images/award.png)  \n6. ![STEAM女力工坊挑戰](./images/steam_workshop.png)  \n\n---\n\n## 三、心得與反思\n在這次IBM企業參訪中，最有趣的環節是**STEAM女力工坊**。活動給予材料（20張色紙、1個紙杯、3雙竹筷、一綑膠帶），要求在15分鐘內完成一座能承重5個鐵塊且高度大於15公分的摩天大樓，並記錄設計理念。\n\n我最初想到將紙折成波浪型，因為珍珠板和紙箱內部構造都是這種設計，應能承受較大重量。然而，組員各自提出不同設計：有人建議交叉折紙成十字型，有人想捲成圓柱狀，有人提議用竹筷做底座。我們嘗試整合多種想法，卻因無法快速決策而耗費一些時間。這讓我體會到，雖然多元想法能激發創意，但缺乏有效整合與分工可能降低效率。  \n\n最令我印象深刻的是**雄女學姊的分享**。她高中時熱愛數學，但大學進入數學系後發現課程內容與興趣不完全契合，轉至財經系，最終進入科技業工作。她說，如果能對高中時期的自己說一句話，會感謝自己勇於嘗試不同領域。這段分享讓我明白，探索興趣與生涯規劃是循序漸進的，即使初期選擇偏差，只要不斷嘗試，仍能找到真正熱愛的領域。聽完後，我感到自己的志向並非遙不可及。  \n\n此外，參訪IBM也讓我對科技企業工作環境與職場文化有真實認識，並體會到**自主學習與問題解決能力的重要性**。  \n\n### 多元表現能力\n- **自主學習能力**：完成IBM SkillsBuild課程，事前查詢公司資訊。  \n- **創意思考與問題解決能力**：在STEAM女力工坊設計摩天大樓，嘗試多種結構。  \n- **團隊合作能力**：整合組員想法並協調分工。  \n- **生涯探索與反思能力**：從學姊分享中思考未來規劃與興趣。  \n- **科技素養與職場理解**：了解科技業運作與技能需求。  \n\n---\n\n## 四、結論\n此次IBM企業參訪讓我在**自主學習、創意思考、團隊合作、生涯探索**等方面獲得明顯成長，也加深對科技企業的理解，為未來學習與職涯規劃奠定基礎。",
    "tags": "心得 ",
    "date": "2024-06-03"
  }
]
